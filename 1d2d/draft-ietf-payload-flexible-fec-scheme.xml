<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY __reference.RFC.2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY __reference.RFC.3550 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3550.xml">
<!ENTITY __reference.RFC.4566 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4566.xml">
<!ENTITY __reference.RFC.5956 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5956.xml">
<!ENTITY __reference.RFC.2733 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2733.xml">
<!ENTITY __reference.RFC.5109 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5109.xml">
<!ENTITY __reference.RFC.3555 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3555.xml">
<!ENTITY __reference.RFC.3264 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3264.xml">
<!ENTITY __reference.I-D.begen-mmusic-fec-grouping-issues SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.begen-mmusic-fec-grouping-issues.xml">
<!ENTITY __reference.RFC.2326 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2326.xml">
<!ENTITY __reference.RFC.2974 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2974.xml">
<!ENTITY __reference.RFC.3711 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3711.xml">
<!ENTITY __reference.RFC.4301 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4301.xml">
<!ENTITY __reference.RFC.5246 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY __reference.RFC.6363 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6363.xml">
<!ENTITY __reference.RFC.7022 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7022.xml">
<!ENTITY __reference.RFC.6838 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6838.xml">
<!ENTITY __reference.adaptive-fec SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.singh-rmcat-adaptive-fec.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc iprnotified="yes" ?>
<?rfc strict="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<?rfc sortrefs="yes" ?>
<?rfc colonspace='yes' ?>
<?rfc tocindent='yes' ?>
<rfc category="std" docName="draft-ietf-payload-flexible-fec-scheme-02"
     ipr="trust200902">
  <front>
    <title abbrev="RTP Payload Format for Parity FEC">RTP Payload Format for
    Flexible Forward Error Correction (FEC)</title>

    <author fullname="Varun Singh" initials="V." surname="Singh">
      <organization>Nemu Dialogue System Oy</organization>

      <address>
        <postal>
          <street>Itamerenkatu 5</street>
          <city>Helsinki</city>
          <region>FIN</region>
          <code>00180</code>
          <country>Finland</country>
        </postal>
        <phone/>

        <email>varun@callstats.io</email>
      </address>
    </author>

    <author fullname="Ali Begen" initials="A." surname="Begen">
      <organization>Cisco Systems</organization>

      <address>
        <postal>
          <street>181 Bay Street</street>
          <city>Toronto</city>
          <region>ON</region>
          <code>M5J 2T3</code>
          <country>Canada</country>
        </postal>

        <email>abegen@cisco.com</email>
      </address>
    </author>

    <author fullname="Mo Zanaty" initials="M." surname="Zanaty">
      <organization>Cisco</organization>

      <address>
        <postal>
          <street/>
          <city>Raleigh</city>
          <region>NC</region>
          <code/>
          <country>USA</country>
        </postal>

        <phone/>
        <email>mzanaty@cisco.com</email>
      </address>
    </author>

    <date />

    <workgroup>PAYLOAD</workgroup>

    <abstract>
      <t>This document defines new RTP payload formats for the Forward Error
      Correction (FEC) packets that are generated by the non-interleaved and
      interleaved parity codes from a source media encapsulated in RTP. These
      parity codes are systematic codes, where a number of repair symbols are
      generated from a set of source symbols. These repair symbols are sent in
      a repair flow separate from the source flow that carries the source
      symbols. The non-interleaved and interleaved parity codes offer a good
      protection against random and bursty packet losses, respectively, at a
      cost of decent complexity. The RTP payload formats that are defined in
      this document address the scalability issues experienced with the
      earlier specifications including RFC 2733, RFC 5109 and SMPTE 2022-1,
      and offer several improvements. Due to these changes, the new payload
      formats are not backward compatible with the earlier specifications, but
      endpoints that do not implement the scheme can still work by simply
      ignoring the FEC packets.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>This document defines new RTP payload formats for the Forward Error
      Correction (FEC) that is generated by the non-interleaved and
      interleaved parity codes from a source media encapsulated in RTP <xref
      target="RFC3550"/>. The type of the source media protected by these
      parity codes can be audio, video, text or application. The FEC data are
      generated according to the media type parameters, which are communicated
      out-of-band (e.g., in SDP). Furthermore, the associations or
      relationships between the source and repair flows may be communicated
      in-band or out-of-band. Situtations where adaptivitiy of FEC parameters
      is desired, the endpoint can use the in-band mechanism, whereas when the
      FEC parameters are fixed, the endpoint may prefer to negotiate them
      out-of-band.</t>

      <t>Both the non-interleaved and interleaved parity codes use the
      eXclusive OR (XOR) operation to generate the repair symbols. In a
      nutshell, the following steps take place:</t>

      <t><list style="numbers">
          <t>The sender determines a set of source packets to be protected by
          FEC based on the media type parameters.</t>

          <t>The sender applies the XOR operation on the source symbols to
          generate the required number of repair symbols.</t>

          <t>The sender packetizes the repair symbols and sends the repair
          packet(s) along with the source packets to the receiver(s) (in
          different flows). The repair packets may be sent proactively or
          on-demand.</t>
        </list></t>

      <t>Note that the source and repair packets belong to different source
      and repair flows, and the sender must provide a way for the receivers to
      demultiplex them, even in the case they are sent in the same 5-tuple
      (i.e., same source/destination address/port with UDP). This is required
      to offer backward compatibility for endpoints that do not understand the
      FEC packets (See <xref target="sec_formats"/>). At the receiver side, if
      all of the source packets are successfully received, there is no need
      for FEC recovery and the repair packets are discarded. However, if there
      are missing source packets, the repair packets can be used to recover
      the missing information. <xref target="fig_encoder"/> and <xref
      target="fig_decoder"/> describe example block diagrams for the
      systematic parity FEC encoder and decoder, respectively.</t>

      <t><figure anchor="fig_encoder"
          title="Block diagram for systematic parity FEC encoder">
          <preamble/>

          <artwork align="center"><![CDATA[                           +------------+
+--+  +--+  +--+  +--+ --> | Systematic | --> +--+  +--+  +--+  +--+
+--+  +--+  +--+  +--+     | Parity FEC |     +--+  +--+  +--+  +--+
                           |  Encoder   |
                           |  (Sender)  | --> +==+  +==+
                           +------------+     +==+  +==+

Source Packet: +--+    Repair Packet: +==+
               +--+                   +==+]]></artwork>
        </figure></t>

      <t><figure anchor="fig_decoder"
          title="Block diagram for systematic parity FEC decoder">
          <preamble/>

          <artwork align="center"><![CDATA[                           +------------+
+--+    X    X    +--+ --> | Systematic | --> +--+  +--+  +--+  +--+
+--+              +--+     | Parity FEC |     +--+  +--+  +--+  +--+
                           |  Decoder   |
            +==+  +==+ --> | (Receiver) |
            +==+  +==+     +------------+

Source Packet: +--+    Repair Packet: +==+    Lost Packet: X
               +--+                   +==+]]></artwork>
        </figure></t>

      <t>In <xref target="fig_decoder"/>, it is clear that the FEC packets
      have to be received by the endpoint within a certain amount of time for
      the FEC recovery process to be useful. In this document, we refer to the
      time that spans a FEC block, which consists of the source packets and
      the corresponding repair packets, as the repair window. At the receiver
      side, the FEC decoder should wait at least for the duration of the
      repair window after getting the first packet in a FEC block, to allow
      all the repair packets to arrive. (The waiting time can be adjusted if
      there are missing packets at the beginning of the FEC block.) The FEC
      decoder can start decoding the already received packets sooner; however,
      it should not register a FEC decoding failure until it waits at least
      for the duration of the repair window.</t>

      <t>Suppose that we have a group of D x L source packets that have
      sequence numbers starting from 1 running to D x L, and a repair packet
      is generated by applying the XOR operation to every L consecutive
      packets as sketched in <xref target="fig_fecblock_row"/>. This process
      is referred to as 1-D non-interleaved FEC protection. As a result of
      this process, D repair packets are generated, which we refer to as
      non-interleaved (or row) FEC packets.</t>

      <t><figure anchor="fig_fecblock_row"
          title="Generating non-interleaved (row) FEC packets">
          <preamble/>

          <artwork align="center"><![CDATA[+--------------------------------------------------+    ---    +===+
| S_1          S_2          S3          ...  S_L   | + |XOR| = |R_1|
+--------------------------------------------------+    ---    +===+
+--------------------------------------------------+    ---    +===+
| S_L+1        S_L+2        S_L+3       ...  S_2xL | + |XOR| = |R_2|
+--------------------------------------------------+    ---    +===+
  .            .            .                .           .       .
  .            .            .                .           .       .
  .            .            .                .           .       .
+--------------------------------------------------+    ---    +===+
| S_(D-1)xL+1  S_(D-1)xL+2  S_(D-1)xL+3 ...  S_DxL | + |XOR| = |R_D|
+--------------------------------------------------+    ---    +===+]]></artwork>
        </figure></t>

      <t>If we apply the XOR operation to the group of the source packets
      whose sequence numbers are L apart from each other, as sketched in <xref
      target="fig_fecblock_column"/>. In this case the endpoint generates L
      repair packets. This process is referred to as 1-D interleaved FEC
      protection, and the resulting L repair packets are referred to as
      interleaved (or column) FEC packets.</t>

      <t><figure anchor="fig_fecblock_column"
          title="Generating interleaved (column) FEC packets">
          <preamble/>

          <artwork align="center"><![CDATA[+-------------+ +-------------+ +-------------+     +-------+
| S_1         | | S_2         | | S3          | ... | S_L   |
| S_L+1       | | S_L+2       | | S_L+3       | ... | S_2xL |
| .           | | .           | |             |     |       |
| .           | | .           | |             |     |       |
| .           | | .           | |             |     |       |
| S_(D-1)xL+1 | | S_(D-1)xL+2 | | S_(D-1)xL+3 | ... | S_DxL |
+-------------+ +-------------+ +-------------+     +-------+
       +               +               +                +
 -------------   -------------   -------------       -------
|     XOR     | |     XOR     | |     XOR     | ... |  XOR  |
 -------------   -------------   -------------       -------
       =               =               =                =
     +===+           +===+           +===+            +===+
     |C_1|           |C_2|           |C_3|      ...   |C_L|
     +===+           +===+           +===+            +===+]]></artwork>
        </figure></t>

      <!-- VS: confirm it is non-interleaved OR interleaved, not both. Both
would imply 2-D FEC! -->

      <section title="Use Cases for 1-D FEC Protection">
        <t>We generate one non-interleaved repair packet out of L consecutive
        source packets or one interleaved repair packet out of D
        non-consecutive source packets. Regardless of whether the repair
        packet is a non-interleaved or an interleaved one, it can provide a
        full recovery of the missing information if there is only one packet
        missing among the corresponding source packets. This implies that 1-D
        non-interleaved FEC protection performs better when the source packets
        are randomly lost. However, if the packet losses occur in bursts, 1-D
        interleaved FEC protection performs better provided that L is chosen
        large enough, i.e., L-packet duration is not shorter than the observed
        burst duration. If the sender generates non-interleaved FEC packets
        and a burst loss hits the source packets, the repair operation fails.
        This is illustrated in <xref target="fig_1d_a"/>.</t>

        <t><figure anchor="fig_1d_a"
            title="Example scenario where 1-D non-interleaved FEC protection fails error recovery (Burst Loss)">
            <artwork align="center"><![CDATA[+---+                +---+  +===+
| 1 |    X      X    | 4 |  |R_1|
+---+                +---+  +===+

+---+  +---+  +---+  +---+  +===+
| 5 |  | 6 |  | 7 |  | 8 |  |R_2|
+---+  +---+  +---+  +---+  +===+

+---+  +---+  +---+  +---+  +===+
| 9 |  | 10|  | 11|  | 12|  |R_3|
+---+  +---+  +---+  +---+  +===+
]]></artwork>
          </figure></t>

        <t>The sender may generate interleaved FEC packets to combat with the
        bursty packet losses. However, two or more random packet losses may
        hit the source and repair packets in the same column. In that case,
        the repair operation fails as well. This is illustrated in <xref
        target="fig_1d_b"/>. Note that it is possible that two burst losses
        may occur back-to-back, in which case interleaved FEC packets may
        still fail to recover the lost data.</t>

        <t><figure anchor="fig_1d_b"
            title="Example scenario where 1-D interleaved FEC protection fails error recovery (Periodic Loss)">
            <artwork align="center"><![CDATA[+---+         +---+  +---+
| 1 |    X    | 3 |  | 4 |
+---+         +---+  +---+

+---+         +---+  +---+
| 5 |    X    | 7 |  | 8 |
+---+         +---+  +---+

+---+  +---+  +---+  +---+
| 9 |  | 10|  | 11|  | 12|
+---+  +---+  +---+  +---+

+===+  +===+  +===+  +===+
|C_1|  |C_2|  |C_3|  |C_4|
+===+  +===+  +===+  +===+]]></artwork>
          </figure></t>
      </section>

      <section anchor="sec_2d" title="Use Cases for 2-D Parity FEC Protection">
        <t>In networks where the source packets are lost both randomly and in
        bursts, the sender ought to generate both non-interleaved and
        interleaved FEC packets. This type of FEC protection is known as 2-D
        parity FEC protection. At the expense of generating more FEC packets,
        thus increasing the FEC overhead, 2-D FEC provides superior protection
        against mixed loss patterns. However, it is still possible for 2-D
        parity FEC protection to fail to recover all of the lost source
        packets if a particular loss pattern occurs. An example scenario is
        illustrated in <xref target="fig_2d1"/>.</t>

        <t><figure anchor="fig_2d1"
            title="Example scenario #1 where 2-D parity FEC protection fails error recovery">
            <artwork align="center"><![CDATA[+---+                +---+  +===+
| 1 |    X      X    | 4 |  |R_1|
+---+                +---+  +===+

+---+  +---+  +---+  +---+  +===+
| 5 |  | 6 |  | 7 |  | 8 |  |R_2|
+---+  +---+  +---+  +---+  +===+

+---+                +---+  +===+
| 9 |    X      X    | 12|  |R_3|
+---+                +---+  +===+

+===+  +===+  +===+  +===+
|C_1|  |C_2|  |C_3|  |C_4|
+===+  +===+  +===+  +===+]]></artwork>
          </figure></t>

        <t>2-D parity FEC protection also fails when at least two rows are
        missing a source and the FEC packet and the missing source packets (in
        at least two rows) are aligned in the same column. An example loss
        pattern is sketched in <xref target="fig_2d2"/>. Similarly, 2-D parity
        FEC protection cannot repair all missing source packets when at least
        two columns are missing a source and the FEC packet and the missing
        source packets (in at least two columns) are aligned in the same
        row.</t>

        <t><figure anchor="fig_2d2"
            title="Example scenario #2 where 2-D parity FEC protection fails error recovery">
            <artwork align="center"><![CDATA[+---+  +---+         +---+
| 1 |  | 2 |    X    | 4 |    X
+---+  +---+         +---+

+---+  +---+  +---+  +---+  +===+
| 5 |  | 6 |  | 7 |  | 8 |  |R_2|
+---+  +---+  +---+  +---+  +===+

+---+  +---+         +---+
| 9 |  | 10|    X    | 12|    X
+---+  +---+         +---+

+===+  +===+  +===+  +===+
|C_1|  |C_2|  |C_3|  |C_4|
+===+  +===+  +===+  +===+]]></artwork>
          </figure></t>
      </section>

      <section title="Overhead Computation">
        <t>The overhead is defined as the ratio of the number of bytes
        belonging to the repair packets to the number of bytes belonging to
        the protected source packets.</t>

        <t>Generally, repair packets are larger in size compared to the source
        packets. Also, not all the source packets are necessarily equal in
        size. However, if we assume that each repair packet carries an equal
        number of bytes carried by a source packet, we can compute the
        overhead for different FEC protection methods as follows:</t>

        <t><list style="symbols">
            <t>1-D Non-interleaved FEC Protection: Overhead = 1/L</t>

            <t>1-D Interleaved FEC Protection: Overhead = 1/D</t>

            <t>2-D Parity FEC Protection: Overhead = 1/L + 1/D</t>
          </list>where L and D are the number of columns and rows in the
        source block, respectively.</t>
      </section>
    </section>

    <section title="Requirements Notation">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"/>.</t>
    </section>

    <section title="Definitions and Notations">
      <t/>

      <section title="Definitions">
        <t>This document uses a number of definitions from <xref
        target="RFC6363"/>.</t>
      </section>

      <section title="Notations">
        <t><list style="symbols">
            <t>L: Number of columns of the source block.</t>

            <t>D: Number of rows of the source block.</t>

            <!-- <t>ToP: Type of protection.</t> -->

            <t>bitmask: Run-length encoding of packets protected by a FEC
            packet. If the bit i in the mask is set to 1, the source packet
            number N + i is protected by this FEC packet. Here, N is the
            sequence number base, which is indicated in the FEC packet as
            well.</t>
          </list></t>
      </section>
    </section>

    <section anchor="sec_formats" title="Packet Formats">
      <t>This section defines the formats of the source and repair
      packets.</t>

      <section title="Source Packets">
        <t>The source packets MUST contain the information that identifies the
        source block and the position within the source block occupied by the
        packet. Since the source packets that are carried within an RTP stream
        already contain unique sequence numbers in their RTP headers <xref
        target="RFC3550"/>, we can identify the source packets in a
        straightforward manner and there is no need to append additional
        field(s). The primary advantage of not modifying the source packets in
        any way is that it provides backward compatibility for the receivers
        that do not support FEC at all. In multicast scenarios, this backward
        compatibility becomes quite useful as it allows the non-FEC-capable
        and FEC-capable receivers to receive and interpret the same source
        packets sent in the same multicast session.</t>
      </section>

      <section anchor="sec_repair_fec_payload_id" title="Repair Packets">
        <t>The repair packets MUST contain information that identifies the
        source block they pertain to and the relationship between the
        contained repair symbols and the original source block. For this
        purpose, we use the RTP header of the repair packets as well as
        another header within the RTP payload, which we refer to as the FEC
        header, as shown in <xref target="fig_repairpacket"/>.</t>

        <t><figure anchor="fig_repairpacket" title="Format of repair packets">
            <preamble/>

            <artwork align="center"><![CDATA[+------------------------------+
|          IP Header           |
+------------------------------+
|       Transport Header       |
+------------------------------+
|          RTP Header          | __
+------------------------------+   |
|          FEC Header          |    \
+------------------------------+     > RTP Payload
|        Repair Symbols        |    /
+------------------------------+ __|]]></artwork>

            <postamble/>
          </figure></t>

        <t>The RTP header is formatted according to <xref target="RFC3550"/>
        with some further clarifications listed below:</t>

        <t><list style="symbols">
            <t>Marker (M) Bit: This bit is not used for this payload type, and
            SHALL be set to 0.</t>

            <t>Payload Type: The (dynamic) payload type for the repair packets
            is determined through out-of-band means. Note that this document
            registers new payload formats for the repair packets (Refer to
            <xref target="sec_parameters"/> for details). According to <xref
            target="RFC3550"/>, an RTP receiver that cannot recognize a
            payload type must discard it. This provides backward
            compatibility. If a non-FEC-capable receiver receives a repair
            packet, it will not recognize the payload type, and hence, will
            discard the repair packet.</t>

            <!---->

            <t>Sequence Number (SN): The sequence number has the standard
            definition. It MUST be one higher than the sequence number in the
            previously transmitted repair packet. The initial value of the
            sequence number SHOULD be random (unpredictable, based on <xref
            target="RFC3550"/>).</t>

            <t>Timestamp (TS): The timestamp SHALL be set to a time
            corresponding to the repair packet's transmission time. Note that
            the timestamp value has no use in the actual FEC protection
            process and is usually useful for jitter calculations.</t>

            <t>Synchronization Source (SSRC): The SSRC value SHALL be randomly
            assigned as suggested by <xref target="RFC3550"/>. This allows the
            sender to multiplex the source and repair flows on the same port,
            or multiplex multiple repair flows on a single port. The repair
            flows SHOULD use the RTCP CNAME field to associate themselves with
            the source flow. <vspace blankLines="1"/>In some networks, the RTP
            Source, which produces the source packets and the FEC Source,
            which generates the repair packets from the source packets may not
            be the same host. In such scenarios, using the same CNAME for the
            source and repair flows means that the RTP Source and the FEC
            Source MUST share the same CNAME (for this specific source-repair
            flow association). A common CNAME may be produced based on an
            algorithm that is known both to the RTP and FEC Source <xref
            target="RFC7022"/>. This usage is compliant with <xref
            target="RFC3550"/>. <vspace blankLines="1"/>Note that due to the
            randomness of the SSRC assignments, there is a possibility of SSRC
            collision. In such cases, the collisions MUST be resolved as
            described in <xref target="RFC3550"/>.</t>
          </list></t>

        <t>The format of the FEC header is shown in <xref
        target="fig_repairfecpayloadid2"/>.</t>

        <t><figure anchor="fig_repairfecpayloadid2"
            title="Format of the FEC header">
            <preamble/>

            <artwork align="center"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|MSK|P|X|  CC   |M| PT recovery |            SN base            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          TS recovery                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        length recovery        |M or Mask[8-15]| N or Mask[0-7]|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Mask [16-47] (optional)                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                    Mask [48-111] (optional)                   +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
          </figure></t>

        <!--
OLD FORMAT:
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|E|I|P|X|  CC   |M| PT recovery |            SN base            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          TS recovery                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Length recovery        |            Padding            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Padding (optional)                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            <t>The E bit is the extension flag reserved to indicate any future
            extension to this specification.</t>

            <t>The I bit is used to indicate the length of padding in the FEC
            header. The padding length SHOULD be selected based on the
            platform architecture and the impact of header length on the
            header processing performance.</t>

            <t>The Padding field is used to pad the FEC header to 12 bytes
            (integer multiples of 32 bits).</t>
 -->

        <t>The FEC header consists of the following fields:</t>

        <t><list style="symbols">
          <t>The MSK field (2 bits) indicates the type of the mask. Namely:
          <figure anchor="table-fec-msk-bits" title="MSK bit values">
            <artwork><![CDATA[
 +---------------+-------------------------------------+
 |    MSK bits   | Use                                 |
 +---------------+-------------------------------------+
 |      00       | 16-bit mask                         |
 |      01       | 48-bit mask                         |
 |      10       | 112-bit mask                        |
 |      11       | packets indicated by offset M and N |
 +---------------+-------------------------------------+
]]></artwork>
          </figure></t>

          <!-- VS: I changed L and D in this section to M and N, to avoid
          confusion with the use of L and D with regular patterns. -->

            <t>The P, X, CC, M and PT recovery fields are used to determine
            the corresponding fields of the recovered packets.</t>

            <t>The SN base field is used to indicate the lowest sequence
            number, taking wrap around into account, of those source packets
            protected by this repair packet.</t>

            <t>The TS recovery field is used to determine the timestamp of the
            recovered packets.</t>

            <t>The Length recovery field is used to determine the length of
            the recovered packets.</t>

            <t>Mask is a run-length encoding of packets protected by the FEC
            packet. Where a bit i set to 1 indicates that the source packet
            with sequence number (SN base + i) is protected by this FEC
            packet.</t>

            <t>If the the MSK field is set to 11, it indicates the offset of
            packets protected by this FEC packet. Consequently, the following
            conditions may occur: <figure
                anchor="table-fec-ld-field"
                title="Interpreting the M and N field values">
                <artwork><![CDATA[
If M=0, N=0,  regular protection pattern code with the values of
              L and D are indicared in the SDP description.
If M>0, N=0,  indicates a non-interleaved (row) FEC of M packets
              starting at SN base.
              Hence, FEC = SN, SN+1, SN+2, ... , SN+(M-1), SN+M.
If M>0, N>0,  indicates interleaved (column) FEC of every M packet
              in a group of N packets starting at SN base.
              Hence, FEC = SN+(Mx0), SN+(Mx1), ... , SN+(MxN).
]]></artwork>
              </figure></t>
          </list></t>

        <t>The details on setting the fields in the FEC header are provided in
        <xref target="sec_repair_packet_construction"/>.</t>

        <t>

          It should be noted that a mask-based approach (similar to the ones
          specified in <xref target="RFC2733"/> and <xref target="RFC5109"/>)
          may not be very efficient to indicate which source packets in the
          current source block are associated with a given repair packet. In
          particular, for the applications that would like to use large source
          block sizes, the size of the mask that is required to describe the
          source-repair packet associations may be prohibitively large. The
          8-bit fields proposed in <xref target="SMPTE2022-1"/> indicate a
          systematized approach. Instead the approach in this document uses
          the 8-bit fields  to indicate packet offsets protected by the FEC
          packet. The approach in <xref target="SMPTE2022-1"/> is inherently
          more efficient for regular patterns, it does not provide flexibility
          to represent other protection patterns (e.g., staircase).
        </t>

        <t>
        <!-- Yet, <xref target="SMPTE2022-1"/> carries the values of D and L in
        8-bit fields. While this approach can support larger blocks compared
        to the mask-based approaches, 8-bit fields may still be limiting when
        a high-bitrate source flow (e.g., a flow carrying ultra high-
        definition video) is to be protected or when network outages/lossy
        periods span more than 255 packets. -->
        </t>
      </section>
    </section>

    <section anchor="sec_parameters" title="Payload Format Parameters">
      <t>This section provides the media subtype registration for the
      non-interleaved and interleaved parity FEC. The parameters that are
      required to configure the FEC encoding and decoding operations are also
      defined in this section.</t>

      <section title="Media Type Registration">
        <t>This registration is done using the template defined in <xref
        target="RFC6838"/> and following the guidance provided in <xref
        target="RFC3555"/>.</t>

        <t>Note to the RFC Editor: In the following sections, please replace
        "XXXX" with the number of this document prior to publication as an
        RFC.</t>

        <section title="Registration of audio/non-interleaved-parityfec">
          <t>Type name: audio</t>

          <t>Subtype name: non-interleaved-parityfec</t>

          <t>Required parameters:</t>

          <t><list style="symbols">
              <t>rate: The RTP timestamp (clock) rate. The rate SHALL be
              larger than 1000 Hz to provide sufficient resolution to RTCP
              operations. However, it is RECOMMENDED to select the rate that
              matches the rate of the protected source RTP stream.</t>

              <t>L: Number of columns of the source block. L is a positive
              integer.</t>

              <t>D: Number of rows of the source block. D is a positive
              integer.</t>

              <t>ToP: Type of the protection applied by the sender: 0 for 1-D
              interleaved FEC protection, 1 for 1-D non-interleaved FEC
              protection, and 2 for 2-D parity FEC protection. The ToP value
              of 3 is reserved for future uses.</t>

              <t>repair-window: The time that spans the source packets and the
              corresponding repair packets. The size of the repair window is
              specified in microseconds.</t>
            </list>Optional parameters: None.</t>

          <t>Encoding considerations: This media type is framed (See Section
          4.8 in the template document <xref target="RFC6838" />) and
          contains binary data.</t>

          <t>Security considerations: See <xref
          target="sec_security_considerations" /> of [RFCXXXX].</t>

          <t>Interoperability considerations: None.</t>

          <t>Published specification: [RFCXXXX].</t>

          <t>Applications that use this media type: Multimedia applications
          that want to improve resiliency against packet loss by sending
          redundant data in addition to the source media.</t>

          <t>Fragment identifier considerations: None.</t>

          <t>Additional information: None.</t>

          <t>Person &amp; email address to contact for further information:
          Varun Singh &lt;varun.singh@iki.fi&gt; and IETF Audio/Video Transport
          Payloads Working Group.</t>

          <t>Intended usage: COMMON.</t>

          <t>Restriction on usage: This media type depends on RTP framing, and
          hence, is only defined for transport via RTP <xref
          target="RFC3550" />.</t>

          <t>Author: Varun Singh &lt;varun.singh@iki.fi&gt;.</t>

          <t>Change controller: IETF Audio/Video Transport Working Group
          delegated from the IESG.</t>

          <t>Provisional registration? (standards tree only): Yes.</t>
        </section>

        <section title="Registration of video/non-interleaved-parityfec">
          <t>Type name: video</t>

          <t>Subtype name: non-interleaved-parityfec</t>

          <t>Required parameters:</t>

          <t><list style="symbols">
              <t>rate: The RTP timestamp (clock) rate. The rate SHALL be
              larger than 1000 Hz to provide sufficient resolution to RTCP
              operations. However, it is RECOMMENDED to select the rate that
              matches the rate of the protected source RTP stream.</t>

              <t>L: Number of columns of the source block. L is a positive
              integer.</t>

              <t>D: Number of rows of the source block. D is a positive
              integer.</t>

              <t>ToP: Type of the protection applied by the sender: 0 for 1-D
              interleaved FEC protection, 1 for 1-D non-interleaved FEC
              protection, and 2 for 2-D parity FEC protection. The ToP value
              of 3 is reserved for future uses.</t>

              <t>repair-window: The time that spans the source packets and the
              corresponding repair packets. The size of the repair window is
              specified in microseconds.</t>
            </list>Optional parameters: None.</t>

          <t>Encoding considerations: This media type is framed (See Section
          4.8 in the template document <xref target="RFC6838" />) and
          contains binary data.</t>

          <t>Security considerations: See <xref
          target="sec_security_considerations" /> of [RFCXXXX].</t>

          <t>Interoperability considerations: None.</t>

          <t>Published specification: [RFCXXXX].</t>

          <t>Applications that use this media type: Multimedia applications
          that want to improve resiliency against packet loss by sending
          redundant data in addition to the source media.</t>

          <t>Fragment identifier considerations: None.</t>

          <t>Additional information: None.</t>

          <t>Person &amp; email address to contact for further information:
          Varun Singh &lt;varun.singh@iki.fi&gt; and IETF Audio/Video Transport
          Payloads Working Group.</t>

          <t>Intended usage: COMMON.</t>

          <t>Restriction on usage: This media type depends on RTP framing, and
          hence, is only defined for transport via RTP <xref
          target="RFC3550" />.</t>

          <t>Author: Varun Singh &lt;varun.singh@iki.fi&gt;.</t>

          <t>Change controller: IETF Audio/Video Transport Working Group
          delegated from the IESG.</t>

          <t>Provisional registration? (standards tree only): Yes.</t>
        </section>

        <section title="Registration of text/non-interleaved-parityfec">
          <t>Type name: text</t>

          <t>Subtype name: non-interleaved-parityfec</t>

          <t>Required parameters:</t>

          <t><list style="symbols">
              <t>rate: The RTP timestamp (clock) rate. The rate SHALL be
              larger than 1000 Hz to provide sufficient resolution to RTCP
              operations. However, it is RECOMMENDED to select the rate that
              matches the rate of the protected source RTP stream.</t>

              <t>L: Number of columns of the source block. L is a positive
              integer.</t>

              <t>D: Number of rows of the source block. D is a positive
              integer.</t>

              <t>ToP: Type of the protection applied by the sender: 0 for 1-D
              interleaved FEC protection, 1 for 1-D non-interleaved FEC
              protection, and 2 for 2-D parity FEC protection. The ToP value
              of 3 is reserved for future uses.</t>

              <t>repair-window: The time that spans the source packets and the
              corresponding repair packets. The size of the repair window is
              specified in microseconds.</t>
            </list>Optional parameters: None.</t>

          <t>Encoding considerations: This media type is framed (See Section
          4.8 in the template document <xref target="RFC6838" />) and
          contains binary data.</t>

          <t>Security considerations: See <xref
          target="sec_security_considerations" /> of [RFCXXXX].</t>

          <t>Interoperability considerations: None.</t>

          <t>Published specification: [RFCXXXX].</t>

          <t>Applications that use this media type: Multimedia applications
          that want to improve resiliency against packet loss by sending
          redundant data in addition to the source media.</t>

          <t>Fragment identifier considerations: None.</t>

          <t>Additional information: None.</t>

          <t>Person &amp; email address to contact for further information:
          Varun Singh &lt;varun.singh@iki.fi&gt; and IETF Audio/Video Transport
          Payloads Working Group.</t>

          <t>Intended usage: COMMON.</t>

          <t>Restriction on usage: This media type depends on RTP framing, and
          hence, is only defined for transport via RTP <xref
          target="RFC3550" />.</t>

          <t>Author: Varun Singh &lt;varun.singh@iki.fi&gt;.</t>

          <t>Change controller: IETF Audio/Video Transport Working Group
          delegated from the IESG.</t>

          <t>Provisional registration? (standards tree only): Yes.</t>
        </section>

        <section title="Registration of application/non-interleaved-parityfec">
          <t>Type name: application</t>

          <t>Subtype name: non-interleaved-parityfec</t>

          <t>Required parameters:</t>

          <t><list style="symbols">
              <t>rate: The RTP timestamp (clock) rate. The rate SHALL be
              larger than 1000 Hz to provide sufficient resolution to RTCP
              operations. However, it is RECOMMENDED to select the rate that
              matches the rate of the protected source RTP stream.</t>

              <t>L: Number of columns of the source block. L is a positive
              integer.</t>

              <t>D: Number of rows of the source block. D is a positive
              integer.</t>

              <t>ToP: Type of the protection applied by the sender: 0 for 1-D
              interleaved FEC protection, 1 for 1-D non-interleaved FEC
              protection, and 2 for 2-D parity FEC protection. The ToP value
              of 3 is reserved for future uses.</t>

              <t>repair-window: The time that spans the source packets and the
              corresponding repair packets. The size of the repair window is
              specified in microseconds.</t>
            </list>Optional parameters: None.</t>

          <t>Encoding considerations: This media type is framed (See Section
          4.8 in the template document <xref target="RFC6838" />) and
          contains binary data.</t>

          <t>Security considerations: See <xref
          target="sec_security_considerations" /> of [RFCXXXX].</t>

          <t>Interoperability considerations: None.</t>

          <t>Published specification: [RFCXXXX].</t>

          <t>Applications that use this media type: Multimedia applications
          that want to improve resiliency against packet loss by sending
          redundant data in addition to the source media.</t>

          <t>Fragment identifier considerations: None.</t>

          <t>Additional information: None.</t>

          <t>Person &amp; email address to contact for further information:
          Varun Singh &lt;varun.singh@iki.fi&gt; and IETF Audio/Video Transport
          Payloads Working Group.</t>

          <t>Intended usage: COMMON.</t>

          <t>Restriction on usage: This media type depends on RTP framing, and
          hence, is only defined for transport via RTP <xref
          target="RFC3550" />.</t>

          <t>Author: Varun Singh &lt;varun.singh@iki.fi&gt;.</t>

          <t>Change controller: IETF Audio/Video Transport Working Group
          delegated from the IESG.</t>

          <t>Provisional registration? (standards tree only): Yes.</t>
        </section>

        <section title="Registration of audio/interleaved-parityfec">
          <t>Type name: audio</t>

          <t>Subtype name: interleaved-parityfec</t>

          <t>Required parameters:</t>

          <t><list style="symbols">
              <t>rate: The RTP timestamp (clock) rate. The rate SHALL be
              larger than 1000 Hz to provide sufficient resolution to RTCP
              operations. However, it is RECOMMENDED to select the rate that
              matches the rate of the protected source RTP stream.</t>

              <t>L: Number of columns of the source block. L is a positive
              integer.</t>

              <t>D: Number of rows of the source block. D is a positive
              integer.</t>

              <t>ToP: Type of the protection applied by the sender: 0 for 1-D
              interleaved FEC protection, 1 for 1-D non-interleaved FEC
              protection, and 2 for 2-D parity FEC protection. The ToP value
              of 3 is reserved for future uses.</t>

              <t>repair-window: The time that spans the source packets and the
              corresponding repair packets. The size of the repair window is
              specified in microseconds.</t>
            </list>Optional parameters: None.</t>

          <t>Encoding considerations: This media type is framed (See Section
          4.8 in the template document <xref target="RFC6838" />) and
          contains binary data.</t>

          <t>Security considerations: See <xref
          target="sec_security_considerations" /> of [RFCXXXX].</t>

          <t>Interoperability considerations: None.</t>

          <t>Published specification: [RFCXXXX].</t>

          <t>Applications that use this media type: Multimedia applications
          that want to improve resiliency against packet loss by sending
          redundant data in addition to the source media.</t>

          <t>Fragment identifier considerations: None.</t>

          <t>Additional information: None.</t>

          <t>Person &amp; email address to contact for further information:
          Varun Singh &lt;varun.singh@iki.fi&gt; and IETF Audio/Video Transport
          Payloads Working Group.</t>

          <t>Intended usage: COMMON.</t>

          <t>Restriction on usage: This media type depends on RTP framing, and
          hence, is only defined for transport via RTP <xref
          target="RFC3550" />.</t>

          <t>Author: Varun Singh &lt;varun.singh@iki.fi&gt;.</t>

          <t>Change controller: IETF Audio/Video Transport Working Group
          delegated from the IESG.</t>

          <t>Provisional registration? (standards tree only): Yes.</t>
        </section>

        <section title="Registration of video/interleaved-parityfec">
          <t>Type name: video</t>

          <t>Subtype name: interleaved-parityfec</t>

          <t>Required parameters:</t>

          <t><list style="symbols">
              <t>rate: The RTP timestamp (clock) rate. The rate SHALL be
              larger than 1000 Hz to provide sufficient resolution to RTCP
              operations. However, it is RECOMMENDED to select the rate that
              matches the rate of the protected source RTP stream.</t>

              <t>L: Number of columns of the source block. L is a positive
              integer.</t>

              <t>D: Number of rows of the source block. D is a positive
              integer.</t>

              <t>ToP: Type of the protection applied by the sender: 0 for 1-D
              interleaved FEC protection, 1 for 1-D non-interleaved FEC
              protection, and 2 for 2-D parity FEC protection. The ToP value
              of 3 is reserved for future uses.</t>

              <t>repair-window: The time that spans the source packets and the
              corresponding repair packets. The size of the repair window is
              specified in microseconds.</t>
            </list>Optional parameters: None.</t>

          <t>Encoding considerations: This media type is framed (See Section
          4.8 in the template document <xref target="RFC6838" />) and
          contains binary data.</t>

          <t>Security considerations: See <xref
          target="sec_security_considerations" /> of [RFCXXXX].</t>

          <t>Interoperability considerations: None.</t>

          <t>Published specification: [RFCXXXX].</t>

          <t>Applications that use this media type: Multimedia applications
          that want to improve resiliency against packet loss by sending
          redundant data in addition to the source media.</t>

          <t>Fragment identifier considerations: None.</t>

          <t>Additional information: None.</t>

          <t>Person &amp; email address to contact for further information:
          Varun Singh &lt;varun.singh@iki.fi&gt; and IETF Audio/Video Transport
          Payloads Working Group.</t>

          <t>Intended usage: COMMON.</t>

          <t>Restriction on usage: This media type depends on RTP framing, and
          hence, is only defined for transport via RTP <xref
          target="RFC3550" />.</t>

          <t>Author: Varun Singh &lt;varun.singh@iki.fi&gt;.</t>

          <t>Change controller: IETF Audio/Video Transport Working Group
          delegated from the IESG.</t>

          <t>Provisional registration? (standards tree only): Yes.</t>
        </section>

        <section title="Registration of text/interleaved-parityfec">
          <t>Type name: text</t>

          <t>Subtype name: interleaved-parityfec</t>

          <t>Required parameters:</t>

          <t><list style="symbols">
              <t>rate: The RTP timestamp (clock) rate. The rate SHALL be
              larger than 1000 Hz to provide sufficient resolution to RTCP
              operations. However, it is RECOMMENDED to select the rate that
              matches the rate of the protected source RTP stream.</t>

              <t>L: Number of columns of the source block. L is a positive
              integer.</t>

              <t>D: Number of rows of the source block. D is a positive
              integer.</t>

              <t>ToP: Type of the protection applied by the sender: 0 for 1-D
              interleaved FEC protection, 1 for 1-D non-interleaved FEC
              protection, and 2 for 2-D parity FEC protection. The ToP value
              of 3 is reserved for future uses.</t>

              <t>repair-window: The time that spans the source packets and the
              corresponding repair packets. The size of the repair window is
              specified in microseconds.</t>
            </list>Optional parameters: None.</t>

          <t>Encoding considerations: This media type is framed (See Section
          4.8 in the template document <xref target="RFC6838" />) and
          contains binary data.</t>

          <t>Security considerations: See <xref
          target="sec_security_considerations"/> of [RFCXXXX].</t>

          <t>Interoperability considerations: None.</t>

          <t>Published specification: [RFCXXXX].</t>

          <t>Applications that use this media type: Multimedia applications
          that want to improve resiliency against packet loss by sending
          redundant data in addition to the source media.</t>

          <t>Fragment identifier considerations: None.</t>

          <t>Additional information: None.</t>

          <t>Person &amp; email address to contact for further information:
          Varun Singh &lt;varun.singh@iki.fi&gt; and IETF Audio/Video Transport
          Payloads Working Group.</t>

          <t>Intended usage: COMMON.</t>

          <t>Restriction on usage: This media type depends on RTP framing, and
          hence, is only defined for transport via RTP <xref
          target="RFC3550"/>.</t>

          <t>Author: Varun Singh &lt;varun.singh@iki.fi&gt;.</t>

          <t>Change controller: IETF Audio/Video Transport Working Group
          delegated from the IESG.</t>

          <t>Provisional registration? (standards tree only): Yes.</t>
        </section>

        <section title="Registration of application/interleaved-parityfec">
          <t>Type name: application</t>

          <t>Subtype name: interleaved-parityfec</t>

          <t>Required parameters:</t>

          <t><list style="symbols">
              <t>rate: The RTP timestamp (clock) rate. The rate SHALL be
              larger than 1000 Hz to provide sufficient resolution to RTCP
              operations. However, it is RECOMMENDED to select the rate that
              matches the rate of the protected source RTP stream.</t>

              <t>L: Number of columns of the source block. L is a positive
              integer.</t>

              <t>D: Number of rows of the source block. D is a positive
              integer.</t>

              <t>ToP: Type of the protection applied by the sender: 0 for 1-D
              interleaved FEC protection, 1 for 1-D non-interleaved FEC
              protection, and 2 for 2-D parity FEC protection. The ToP value
              of 3 is reserved for future uses.</t>

              <t>repair-window: The time that spans the source packets and the
              corresponding repair packets. The size of the repair window is
              specified in microseconds.</t>
            </list>Optional parameters: None.</t>

          <t>Encoding considerations: This media type is framed (See Section
          4.8 in the template document <xref target="RFC6838"/>) and
          contains binary data.</t>

          <t>Security considerations: See <xref
          target="sec_security_considerations"/> of [RFCXXXX].</t>

          <t>Interoperability considerations: None.</t>

          <t>Published specification: [RFCXXXX].</t>

          <t>Applications that use this media type: Multimedia applications
          that want to improve resiliency against packet loss by sending
          redundant data in addition to the source media.</t>

          <t>Fragment identifier considerations: None.</t>

          <t>Additional information: None.</t>

          <t>Person &amp; email address to contact for further information:
          Varun Singh &lt;varun.singh@iki.fi&gt; and IETF Audio/Video Transport
          Payloads Working Group.</t>

          <t>Intended usage: COMMON.</t>

          <t>Restriction on usage: This media type depends on RTP framing, and
          hence, is only defined for transport via RTP <xref
          target="RFC3550" />.</t>

          <t>Author: Varun Singh &lt;varun.singh@iki.fi&gt;.</t>

          <t>Change controller: IETF Audio/Video Transport Working Group
          delegated from the IESG.</t>

          <t>Provisional registration? (standards tree only): Yes.</t>
        </section>

      </section>

      <section title="Mapping to SDP Parameters">
        <t>Applications that are using RTP transport commonly use Session
        Description Protocol (SDP) <xref target="RFC4566"/> to describe their
        RTP sessions. The information that is used to specify the media types
        in an RTP session has specific mappings to the fields in an SDP
        description. In this section, we provide these mappings for the media
        subtypes registered by this document. Note that if an application does
        not use SDP to describe the RTP sessions, an appropriate mapping must
        be defined and used to specify the media types and their parameters
        for the control/description protocol employed by the application.</t>

        <t>The mapping of the media type specification for
        "non-interleaved-parityfec" and "interleaved-parityfec" and their
        parameters in SDP is as follows:</t>

        <t><list style="symbols">
            <t>The media type (e.g., "application") goes into the "m=" line as
            the media name.</t>

            <t>The media subtype goes into the "a=rtpmap" line as the encoding
            name. The RTP clock rate parameter ("rate") also goes into the
            "a=rtpmap" line as the clock rate.</t>

            <t>The remaining required payload-format-specific parameters go
            into the "a=fmtp" line by copying them directly from the media
            type string as a semicolon-separated list of parameter=value
            pairs.</t>
          </list>SDP examples are provided in <xref target="sec_sdp"/>.</t>

        <section title="Offer-Answer Model Considerations">
          <t>When offering 1-D interleaved parity FEC over RTP using SDP in an
          Offer/Answer model <xref target="RFC3264"/>, the following
          considerations apply:</t>

          <t><list style="symbols">
              <t>Each combination of the L and D parameters produces a
              different FEC data and is not compatible with any other
              combination. A sender application may desire to offer multiple
              offers with different sets of L and D values as long as the
              parameter values are valid. The receiver SHOULD normally choose
              the offer that has a sufficient amount of interleaving. If
              multiple such offers exist, the receiver may choose the offer
              that has the lowest overhead or the one that requires the
              smallest amount of buffering. The selection depends on the
              application requirements.</t>

              <t>The value for the repair-window parameter depends on the L
              and D values and cannot be chosen arbitrarily. More
              specifically, L and D values determine the lower limit for the
              repair-window size. The upper limit of the repair-window size
              does not depend on the L and D values.</t>

              <t>Although combinations with the same L and D values but with
              different repair-window sizes produce the same FEC data, such
              combinations are still considered different offers. The size of
              the repair-window is related to the maximum delay between the
              transmission of a source packet and the associated repair
              packet. This directly impacts the buffering requirement on the
              receiver side and the receiver must consider this when choosing
              an offer.</t>

              <t>There are no optional format parameters defined for this
              payload. Any unknown option in the offer MUST be ignored and
              deleted from the answer. If FEC is not desired by the receiver,
              it can be deleted from the answer.</t>
            </list></t>
        </section>

        <section title="Declarative Considerations">
          <t>In declarative usage, like SDP in the Real-time Streaming
          Protocol (RTSP) <xref target="RFC2326"/> or the Session Announcement
          Protocol (SAP) <xref target="RFC2974"/>, the following
          considerations apply:</t>

          <t><list style="symbols">
              <t>The payload format configuration parameters are all
              declarative and a participant MUST use the configuration that is
              provided for the session.</t>

              <t>More than one configuration may be provided (if desired) by
              declaring multiple RTP payload types. In that case, the
              receivers should choose the repair flow that is best for
              them.</t>
            </list></t>
        </section>
      </section>
    </section>

    <section title="Protection and Recovery Procedures">
      <t>This section provides a complete specification of the 1-D and 2-D
      parity codes and their RTP payload formats.</t>

      <section title="Overview">
        <t>The following sections specify the steps involved in generating the
        repair packets and reconstructing the missing source packets from the
        repair packets.</t>
      </section>

      <section anchor="sec_repair_packet_construction"
               title="Repair Packet Construction">
        <t>The RTP header of a repair packet is formed based on the guidelines
        given in <xref target="sec_repair_fec_payload_id"/>.</t>

        <t>The FEC header includes 12 octets (or upto 28 octets when the longer
        optional masks are used). It is constructed by applying the XOR operation
        on the bit strings that are generated from the individual source packets
        protected by this particular repair packet. The set of the source
        packets that are associated with a given repair packet can be computed
        by the formula given in <xref target="sec_associating_source_repair"/>.</t>

        <t>The bit string is formed for each source packet by concatenating
        the following fields together in the order specified:</t>

        <t><list style="symbols">
            <t>The first 64 bits of the RTP header (64 bits).</t>

            <t>Unsigned network-ordered 16-bit representation of the source
            packet length in bytes minus 12 (for the fixed RTP header), i.e.,
            the sum of the lengths of all the following if present: the CSRC
            list, extension header, RTP payload and RTP padding (16 bits).</t>
          </list>

          By applying the parity operation on the bit strings produced from
          the source packets, we generate the FEC bit string. The FEC header is
          generated from the FEC bit string as follows: </t>

        <t><list style="symbols">
          <t>The first (most significant) 2 bits in the FEC bit string are
          skipped. The MSK bits in the FEC header are set to the appropriate
          value, i.e., it depends on the chosen bitmask length.</t>

          <t>The next bit in the FEC bit string is written into the P
          recovery bit in the FEC header.</t>

          <t>The next bit in the FEC bit string is written into the X
          recovery bit in the FEC header.</t>

          <t>The next 4 bits of the FEC bit string are written into the CC
          recovery field in the FEC header.</t>

          <t>The next bit is written into the M recovery bit in the FEC
          header.</t>

          <t>The next 7 bits of the FEC bit string are written into the PT
          recovery field in the FEC header.</t>

          <t>The next 16 bits are skipped.</t>

          <t>The next 32 bits of the FEC bit string are written into the TS
          recovery field in the FEC header.</t>

          <t>The next 16 bits are written into the length recovery field in
          the FEC header.</t>

          <t>Depending on the chosen MSK value, the bit mask of appropriate
          length will be set to the appropriate values.</t>
        </list>

        As described in <xref target="sec_repair_fec_payload_id"/>, the SN
        base field of the FEC header MUST be set to the lowest sequence number
        of the source packets protected by this repair packet. When MSK
        represents a bitmask (MSK=00,01,10), the SN base field corresponds to
        the lowest sequence number indicated in the bitmask.  When MSK=11, the
        following considerations apply: 1) for the interleaved FEC packets,
        this corresponds to the lowest sequence number of the source packets
        that forms the column, 2) for the non-interleaved FEC packets, the SN
        base field MUST be set to the lowest sequence number of the source
        packets that forms the row.</t>

        <t>The repair packet payload consists of the bits that are generated
        by applying the XOR operation on the payloads of the source RTP
        packets. If the payload lengths of the source packets are not equal,
        each shorter packet MUST be padded to the length of the longest packet
        by adding octet 0's at the end.</t>

        <t>Due to this possible padding and mandatory FEC header, a repair
        packet has a larger size than the source packets it protects. This may
        cause problems if the resulting repair packet size exceeds the Maximum
        Transmission Unit (MTU) size of the path over which the repair flow is
        sent.</t>
      </section>

      <section title="Source Packet Reconstruction">
        <t>This section describes the recovery procedures that are required to
        reconstruct the missing source packets. The recovery process has two
        steps. In the first step, the FEC decoder determines which source and
        repair packets should be used in order to recover a missing packet. In
        the second step, the decoder recovers the missing packet, which
        consists of an RTP header and RTP payload.</t>

        <t>In the following, we describe the RECOMMENDED algorithms for the
        first and second steps. Based on the implementation, different
        algorithms MAY be adopted. However, the end result MUST be identical
        to the one produced by the algorithms described below.</t>

        <t>Note that the same algorithms are used by the 1-D parity codes,
        regardless of whether the FEC protection is applied over a column or a
        row. The 2-D parity codes, on the other hand, usually require multiple
        iterations of the procedures described here. This iterative decoding
        algorithm is further explained in <xref
        target="sec_iterative_decoding"/>.</t>

        <section anchor="sec_associating_source_repair"
                 title="Associating the Source and Repair Packets">

          <t>
            We denote the set of the source packets associated with repair
            packet p* by set T(p*). Note that in a source block whose size is L
            columns by D rows, set T includes D source packets plus one repair
            packet for the FEC protection applied over a column, and L source
            packets plus one repair packet for the FEC protection applied over a
            row. Recall that 1-D interleaved and non-interleaved FEC protection
            can fully recover the missing information if there is only one
            source packet missing in set T. If there are more than one source
            packets missing in set T, 1-D FEC protection will not work.
          </t>

          <section anchor="sec_repair_sdp" title="Signaled in SDP">
            <t>
              The first step is associating the source and repair packets. If
              the endpoint relies entirely on out-of-band signaling (MSK=11, and
              M=N=0), then this information may be inferred from the media type
              parameters specified in the SDP description. Furtheremore, the
              payload type field in the RTP header, assists the receiver
              distinguish an interleaved or non-interleaved FEC packet.
            </t>

            <t>Mathematically, for any received repair packet, p*, we can
            determine the sequence numbers of the source packets that are
            protected by this repair packet as follows:</t>

            <t> <figure> <preamble/> <artwork align="center">
              <![CDATA[p*_snb + i * X_1 (modulo 65536)]]>
            </artwork> </figure> </t>

            <t>where p*_snb denotes the value in the SN base field of p*'s FEC
            header, X_1 is set to L and 1 for the interleaved and
            non-interleaved FEC packets, respectively, and</t>

            <t> <figure> <preamble/> <artwork align="center">
              <![CDATA[0 <= i < X_2]]>
            </artwork> </figure> </t>

            <t>where X_2 is set to D and L for the interleaved and
            non-interleaved FEC packets, respectively.</t>
          </section>

          <section anchor="sec_repair_bitmask" title="Using bitmasks">
            <t>
              When using fixed size bitmasks (16-, 48-, 112-bits), the SN base
              field in the FEC header indicates the lowest sequence number of
              the source packets that forms the FEC packet. Finally, the bits
              maked by "1" in the bitmask are offsets from the SN base and
              make up the rest of the packets protected by the FEC packet.
              The bitmasks are able to represent arbitrary protection patterns,
              for example, 1-D interleaved, 1-D non-interleaved, 2-D, staircase.
            </t>
          </section>

          <section anchor="sec_repair_offset" title="Using M and N Offsets">
            <t>
              When value of M is non-zero, the 8-bit fields indicate the
              offset of packets protected by an interleaved (N>0) or
              non-interleaved (N=0) FEC packet. Using a combination of
              interleaved and non-interleaved FEC packets can form
              2-D protection patterns.
            </t>
            <t>Mathematically, for any received repair packet, p*,
              we can determine the sequence numbers of the source
              packets that are protected by this repair packet are as
              follows:</t>
              <t> <figure> <preamble/> <artwork align="center">
              <![CDATA[When N = 0:
  p*_snb, p*_snb+1,..., p*_snb+(M-1), p*_snb+M
When N > 0:
  p*_snb, p*_snb+(Mx1), p*_snb+(Mx2),..., p*_snb+(Mx(N-1)), p*_snb+(MxN)]]>
            </artwork> </figure> </t>

          </section>
        </section>

        <section anchor="sec_recovering_rtp_header"
                 title="Recovering the RTP Header">
          <t>For a given set T, the procedure for the recovery of the RTP
          header of the missing packet, whose sequence number is denoted by
          SEQNUM, is as follows:</t>

          <t><list style="numbers">
              <t>For each of the source packets that are successfully received
              in T, compute the 80-bit string by concatenating the first 64
              bits of their RTP header and the unsigned network-ordered 16-bit
              representation of their length in bytes minus 12.</t>

              <t>For the repair packet in T, compute the FEC bit string from
              the first 80 bits of the FEC header.</t>

              <t>Calculate the recovered bit string as the XOR of the bit
              strings generated from all source packets in T and the FEC bit
              string generated from the repair packet in T.</t>

              <t>Create a new packet with the standard 12-byte RTP header and
              no payload.</t>

              <t>Set the version of the new packet to 2. Skip the first 2 bits
              in the recovered bit string.</t>

              <t>Set the Padding bit in the new packet to the next bit in the
              recovered bit string.</t>

              <t>Set the Extension bit in the new packet to the next bit in
              the recovered bit string.</t>

              <t>Set the CC field to the next 4 bits in the recovered bit
              string.</t>

              <t>Set the Marker bit in the new packet to the next bit in the
              recovered bit string.</t>

              <t>Set the Payload type in the new packet to the next 7 bits in
              the recovered bit string.</t>

              <t>Set the SN field in the new packet to SEQNUM. Skip the next
              16 bits in the recovered bit string.</t>

              <t>Set the TS field in the new packet to the next 32 bits in the
              recovered bit string.</t>

              <t>Take the next 16 bits of the recovered bit string and set the
              new variable Y to whatever unsigned integer this represents
              (assuming network order). Convert Y to host order. Y represents
              the length of the new packet in bytes minus 12 (for the fixed
              RTP header), i.e., the sum of the lengths of all the following
              if present: the CSRC list, header extension, RTP payload and RTP
              padding.</t>

              <t>Set the SSRC of the new packet to the SSRC of the source RTP
              stream.</t>
            </list>This procedure recovers the header of an RTP packet up to
          (and including) the SSRC field.</t>
        </section>

        <section anchor="sec_recovering_rtp_payload"
                 title="Recovering the RTP Payload">
          <t>Following the recovery of the RTP header, the procedure for the
          recovery of the RTP payload is as follows:</t>

          <t><list style="numbers">
              <t>Append Y bytes to the new packet.</t>

              <t>For each of the source packets that are successfully received
              in T, compute the bit string from the Y octets of data starting
              with the 13th octet of the packet. If any of the bit strings
              generated from the source packets has a length shorter than Y,
              pad them to that length. The padding of octet 0 MUST be added at
              the end of the bit string. Note that the information of the
              first 8 octets are protected by the FEC header.</t>

              <t>For the repair packet in T, compute the FEC bit string from
              the repair packet payload, i.e., the Y octets of data following
              the FEC header. Note that the FEC header may be 12, 16, 32
              octets depending on the length of the bitmask.</t>

              <t>Calculate the recovered bit string as the XOR of the bit
              strings generated from all source packets in T and the FEC bit
              string generated from the repair packet in T.</t>

              <t>Append the recovered bit string (Y octets) to the new packet
              generated in <xref target="sec_recovering_rtp_header"/>.</t>
            </list></t>
        </section>

        <section anchor="sec_iterative_decoding"
                 title="Iterative Decoding Algorithm for the 2-D Parity FEC Protection">
                 <!-- VS: FIXME: multiple passes over source and repair streams -->
          <t>In 2-D parity FEC protection, the sender generates both
          non-interleaved and interleaved FEC packets to combat with the mixed
          loss patterns (random and bursty). At the receiver side, these FEC
          packets are used iteratively to overcome the shortcomings of the 1-D
          non-interleaved/interleaved FEC protection and improve the chances
          of full error recovery.</t>

          <t>The iterative decoding algorithm runs as follows:</t>

          <t><list style="numbers">
              <t>Set num_recovered_until_this_iteration to zero</t>

              <t>Set num_recovered_so_far to zero</t>

              <t>Recover as many source packets as possible by using the
              non-interleaved FEC packets as outlined in <xref
              target="sec_recovering_rtp_header"/> and <xref
              target="sec_recovering_rtp_payload"/>, and increase the value of
              num_recovered_so_far by the number of recovered source
              packets.</t>

              <t>Recover as many source packets as possible by using the
              interleaved FEC packets as outlined in <xref
              target="sec_recovering_rtp_header"/> and <xref
              target="sec_recovering_rtp_payload"/>, and increase the value of
              num_recovered_so_far by the number of recovered source
              packets.</t>

              <t>If num_recovered_so_far &gt;
              num_recovered_until_this_iteration<vspace
              blankLines="0"/>---num_recovered_until_this_iteration =
              num_recovered_so_far<vspace blankLines="0"/>---Go to step
              3<vspace blankLines="0"/>Else<vspace
              blankLines="0"/>---Terminate</t>
            </list></t>

          <t>The algorithm terminates either when all missing source packets
          are fully recovered or when there are still remaining missing source
          packets but the FEC packets are not able to recover any more source
          packets. For the example scenarios when the 2-D parity FEC
          protection fails full recovery, refer to <xref target="sec_2d"/>.
          Upon termination, variable num_recovered_so_far has a value equal to
          the total number of recovered source packets.</t>

          <t>Example:</t>

          <t>Suppose that the receiver experienced the loss pattern sketched
          in <xref target="fig_ite1"/>.</t>

          <t><figure anchor="fig_ite1"
              title="Example loss pattern for the iterative decoding algorithm">
              <artwork align="center"><![CDATA[              +---+  +---+  +===+
  X      X    | 3 |  | 4 |  |R_1|
              +---+  +---+  +===+

+---+  +---+  +---+  +---+  +===+
| 5 |  | 6 |  | 7 |  | 8 |  |R_2|
+---+  +---+  +---+  +---+  +===+

+---+                +---+  +===+
| 9 |    X      X    | 12|  |R_3|
+---+                +---+  +===+

+===+  +===+  +===+  +===+
|C_1|  |C_2|  |C_3|  |C_4|
+===+  +===+  +===+  +===+]]></artwork>
            </figure></t>

          <t>The receiver executes the iterative decoding algorithm and
          recovers source packets #1 and #11 in the first iteration. The
          resulting pattern is sketched in <xref target="fig_ite2"/>.</t>

          <t><figure anchor="fig_ite2"
              title="The resulting pattern after the first iteration">
              <artwork align="center"><![CDATA[+---+         +---+  +---+  +===+
| 1 |    X    | 3 |  | 4 |  |R_1|
+---+         +---+  +---+  +===+

+---+  +---+  +---+  +---+  +===+
| 5 |  | 6 |  | 7 |  | 8 |  |R_2|
+---+  +---+  +---+  +---+  +===+

+---+         +---+  +---+  +===+
| 9 |    X    | 11|  | 12|  |R_3|
+---+         +---+  +---+  +===+

+===+  +===+  +===+  +===+
|C_1|  |C_2|  |C_3|  |C_4|
+===+  +===+  +===+  +===+]]></artwork>
            </figure></t>

          <t>Since the if condition holds true, the receiver runs a new
          iteration. In the second iteration, source packets #2 and #10 are
          recovered, resulting in a full recovery as sketched in <xref
          target="fig_ite3"/>.</t>

          <t><figure anchor="fig_ite3"
              title="The resulting pattern after the second iteration">
              <artwork align="center"><![CDATA[+---+  +---+  +---+  +---+  +===+
| 1 |  | 2 |  | 3 |  | 4 |  |R_1|
+---+  +---+  +---+  +---+  +===+

+---+  +---+  +---+  +---+  +===+
| 5 |  | 6 |  | 7 |  | 8 |  |R_2|
+---+  +---+  +---+  +---+  +===+

+---+  +---+  +---+  +---+  +===+
| 9 |  | 10|  | 11|  | 12|  |R_3|
+---+  +---+  +---+  +---+  +===+

+===+  +===+  +===+  +===+
|C_1|  |C_2|  |C_3|  |C_4|
+===+  +===+  +===+  +===+]]></artwork>
            </figure></t>
        </section>
      </section>
    </section>

    <section anchor="sec_sdp" title="SDP Examples">
      <t>This section provides two SDP <xref target="RFC4566"/> examples. The
      examples use the FEC grouping semantics defined in <xref
      target="RFC5956"/>.</t>

      <section title="Example SDP for 1-D Parity FEC Protection">
        <t>In this example, we have one source video stream (ssrc:1234) and one
        FEC repair stream (ssrc:2345). We form one FEC group with the
        "a=ssrc-group:FEC-FR 1234 2345" line. The source and repair streams are
        multiplexed on different SSRCs. The repair window is set to 200 ms.</t>

        <t><figure>
            <preamble/>

            <artwork><![CDATA[
     v=0
     o=ali 1122334455 1122334466 IN IP4 fec.example.com
     s=1-D Interleaved Parity FEC Example
     t=0 0
     m=video 30000 RTP/AVP 100 110
     c=IN IP4 233.252.0.1/127
     a=rtpmap:100 MP2T/90000
     a=rtpmap:110 interleaved-parityfec/90000
     a=fmtp:110 L:5; D:10; ToP:0; repair-window:200000
     a=ssrc:1234
     a=ssrc:2345
     a=ssrc-group:FEC-FR 1234 2345
]]></artwork>
          </figure></t>
      </section>

      <section title="Example SDP for 2-D Parity FEC Protection">
        <t>In this example, we have one source video stream (ssrc:1234) and two
        FEC repair streams (ssrc:2345 and ssrc:3456). We form one FEC group with the
        "a=ssrc-group:FEC-FR 1234 2345 3456" line. The source and repair streams are
        multiplexed on different SSRCs. The repair window is set to 200 ms.</t>

        <t><figure>
            <preamble/>

            <artwork><![CDATA[
     v=0
     o=ali 1122334455 1122334466 IN IP4 fec.example.com
     s=2-D Parity FEC Example
     t=0 0
     m=video 30000 RTP/AVP 100 110 111
     c=IN IP4 233.252.0.1/127
     a=rtpmap:100 MP2T/90000
     a=rtpmap:110 interleaved-parityfec/90000
     a=fmtp:110 L:5; D:10; ToP:2; repair-window:200000
     a=rtpmap:111 non-interleaved-parityfec/90000
     a=fmtp:111 L:5; D:10; ToP:2; repair-window:200000
     a=ssrc:1234
     a=ssrc:2345
     a=ssrc:3456
     a=ssrc-group:FEC-FR 1234 2345 3456
]]></artwork>

            <postamble/>
          </figure></t>

        <t>Note that the sender might be generating two repair flows carrying
        non-interleaved and interleaved FEC packets, however the receiver
        might be interested only in the interleaved FEC packets. The receiver
        can identify the repair flow carrying the desired repair data by
        checking the payload types associated with each repair flow described
        in the SDP description.</t>
      </section>
    </section>

    <section title="Congestion Control Considerations">
      <t>FEC is an effective approach to provide applications resiliency
      against packet losses. However, in networks where the congestion is a
      major contributor to the packet loss, the potential impacts of using FEC
      SHOULD be considered carefully before injecting the repair flows into
      the network. In particular, in bandwidth-limited networks, FEC repair
      flows may consume most or all of the available bandwidth and
      consequently may congest the network. In such cases, the applications
      MUST NOT arbitrarily increase the amount of FEC protection since doing
      so may lead to a congestion collapse. If desired, stronger FEC
      protection MAY be applied only after the source rate has been
      reduced <xref target="I-D.singh-rmcat-adaptive-fec" />.</t>

      <t>In a network-friendly implementation, an application SHOULD NOT
      send/receive FEC repair flows if it knows that sending/receiving those
      FEC repair flows would not help at all in recovering the missing
      packets. However, it MAY still continue to use FEC if considered for
      bandwidth estimation instead of speculatively probe for additional
      capacity <xref target="Holmer13" /><xref target="Nagy14" />.
      It is RECOMMENDED that the amount of FEC protection is adjusted
      dynamically based on the packet loss rate observed by the applications.</t>

      <t>In multicast scenarios, it may be difficult to optimize the FEC
      protection per receiver. If there is a large variation among the levels
      of FEC protection needed by different receivers, it is RECOMMENDED that
      the sender offers multiple repair flows with different levels of FEC
      protection and the receivers join the corresponding multicast sessions
      to receive the repair flow(s) that is best for them.</t>

      <t>Editor's note: Additional congestion control considerations regarding
      the use of 2-D parity codes should be added here.</t>
    </section>

    <section anchor="sec_security_considerations"
             title="Security Considerations">
      <t>RTP packets using the payload format defined in this specification
      are subject to the security considerations discussed in the RTP
      specification <xref target="RFC3550"/> and in any applicable RTP
      profile. The main security considerations for the RTP packet carrying
      the RTP payload format defined within this memo are confidentiality,
      integrity and source authenticity. Confidentiality is achieved by
      encrypting the RTP payload. Integrity of the RTP packets is achieved
      through a suitable cryptographic integrity protection mechanism. Such a
      cryptographic system may also allow the authentication of the source of
      the payload. A suitable security mechanism for this RTP payload format
      should provide confidentiality, integrity protection, and at least
      source authentication capable of determining if an RTP packet is from a
      member of the RTP session.</t>

      <t>Note that the appropriate mechanism to provide security to RTP and
      payloads following this memo may vary. It is dependent on the
      application, transport and signaling protocol employed. Therefore, a
      single mechanism is not sufficient, although if suitable, using the
      Secure Real-time Transport Protocol (SRTP) <xref target="RFC3711"/> is
      recommended. Other mechanisms that may be used are IPsec <xref
      target="RFC4301"/> and Transport Layer Security (TLS) <xref
      target="RFC5246"/> (RTP over TCP); other alternatives may exist.</t>
    </section>

    <section anchor="sec_iana_considerations" title="IANA Considerations">
      <t>New media subtypes are subject to IANA registration. For the
      registration of the payload formats and their parameters introduced in
      this document, refer to <xref target="sec_parameters"/>.</t>
    </section>

    <section title="Acknowledgments">
      <t>Some parts of this document are borrowed from <xref
      target="RFC5109"/>. Thus, the author would like to thank the editor of
      <xref target="RFC5109"/> and those who contributed to <xref
      target="RFC5109"/>.</t>
    </section>

    <section title="Change Log">

      <t> Note to the RFC-Editor: please remove this section prior to
        publication as an RFC.</t>

      <section title="draft-ietf-payload-flexible-fec-scheme-00">
        <t>Initial WG version, based on draft-singh-payload-1d2d-parity-scheme-00.</t>
      </section>

      <section title="draft-singh-payload-1d2d-parity-scheme-00">
        <t>This is the initial version, which is based on
        draft-ietf-fecframe-1d2d-parity-scheme-00. The following are the major
        changes compared to that document:</t>

        <t><list style="symbols">
            <t>Updated packet format with 16-, 48-, 112- bitmask.</t>
            <t>Updated the sections on: repair packet construction,
              source packet construction.</t>
            <t>Updated the media type registration and aligned to RFC6838.</t>
          </list></t>
      </section>

      <section title="draft-ietf-fecframe-1d2d-parity-scheme-00">
        <t><list style="symbols">
            <t>Some details were added regarding the use of CNAME field.</t>

            <t>Offer-Answer and Declarative Considerations sections have been
            completed.</t>

            <t>Security Considerations section has been completed.</t>

            <t>The timestamp field definition has changed.</t>
          </list></t>
      </section>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      &__reference.RFC.2119;

      &__reference.RFC.3550;

      &__reference.RFC.4566;

      <!-- &__reference.RFC.4288; updated by RFC6838-->

      &__reference.RFC.3555;

      &__reference.RFC.5956;

      &__reference.RFC.3264;

      &__reference.RFC.6363;

      &__reference.RFC.7022;

      &__reference.RFC.6838;
    </references>

    <references title="Informative References">
      &__reference.RFC.2733;

      &__reference.RFC.5109;

      <reference anchor="SMPTE2022-1">
        <front>
          <title>Forward Error Correction for Real-Time Video/Audio Transport
          over IP Networks</title>

          <author fullname="" surname="SMPTE 2022-1-2007">
            <organization/>
          </author>

          <date year="2007"/>
        </front>
      </reference>

      &__reference.RFC.2326;

      &__reference.RFC.2974;

      &__reference.RFC.3711;

      &__reference.RFC.4301;

      &__reference.RFC.5246;

      &__reference.adaptive-fec;

      <reference anchor="Nagy14">
        <front>
          <title>Congestion Control using FEC for Conversational Multimedia Communication</title>
          <author initials="M" surname="Nagy"></author>
          <author initials="V" surname="Singh"></author>
          <author initials="J"  surname="Ott"></author>
          <author initials="L" surname="Eggert"></author>
          <date month="3" year="2014" />
        </front>
        <seriesInfo name="Proc. of 5th ACM Internation Conference on  Multimedia Systems (MMSys 2014)" value="" />
      </reference>

      <reference anchor="Holmer13">
        <front>
          <title>Handling Packet Loss in WebRTC</title>
          <author initials="S" surname="Holmer"></author>
          <author initials="M" surname="Shemer"></author>
          <author initials="M"  surname="Paniconi"></author>
          <date month="9" year="2013" />
        </front>
        <seriesInfo name="Proc. of IEEE International Conference on Image Processing (ICIP 2013)" value="" />
      </reference>

    </references>
  </back>
</rfc>
