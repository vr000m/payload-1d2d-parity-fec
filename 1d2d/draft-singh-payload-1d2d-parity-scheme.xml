<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY __reference.RFC.2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY __reference.RFC.3550 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3550.xml">
<!ENTITY __reference.RFC.4566 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4566.xml">
<!ENTITY __reference.RFC.4756 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4756.xml">
<!ENTITY __reference.RFC.2733 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2733.xml">
<!ENTITY __reference.RFC.5109 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5109.xml">
<!ENTITY __reference.RFC.4288 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4288.xml">
<!ENTITY __reference.RFC.3555 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3555.xml">
<!ENTITY __reference.RFC.3264 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3264.xml">
<!ENTITY __reference.I-D.begen-mmusic-fec-grouping-issues SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.begen-mmusic-fec-grouping-issues.xml">
<!ENTITY __reference.RFC.2326 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2326.xml">
<!ENTITY __reference.RFC.2974 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2974.xml">
<!ENTITY __reference.RFC.3711 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3711.xml">
<!ENTITY __reference.RFC.4301 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4301.xml">
<!ENTITY __reference.RFC.5246 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc iprnotified="yes" ?>
<?rfc strict="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<?rfc sortrefs="yes" ?>
<?rfc colonspace='yes' ?>
<?rfc tocindent='yes' ?>
<rfc category="std" docName="draft-singh-payload-rtp-1d2d-parity-scheme-00"
     ipr="pre5378Trust200902">
  <front>
    <title abbrev="RTP Payload Format for Parity FEC">RTP Payload Format for
    Non-Interleaved and Interleaved Parity FEC</title>

    <author fullname="Varun Singh" initials="V." surname="Singh">
      <organization>Aalto University</organization>
      <address>
      <postal>
      <street></street>
      <city>Espoo</city>
      <region>FIN</region>
      <code></code>
      <country>Finland</country>
      </postal>
      <phone></phone>
      <email>varun@comnet.tkk.fi</email>
      </address>
    </author>

    <author fullname="Ali Begen" initials="A." surname="Begen">
      <organization>Cisco Systems</organization>
      <address>
        <postal>
          <street>181 Bay Street</street>
          <city>Toronto</city>
          <region>ON</region>
          <code>M5J 2T3</code>
          <country>Canada</country>
        </postal>
        <email>abegen@cisco.com</email>
      </address>
    </author>

    <author fullname="Mo Zanaty" initials="M." surname="Zanaty">
      <organization>Cisco</organization>
      <address>
      <postal>
      <street></street>
      <city>Raleigh</city>
      <region>NC</region>
      <code></code>
      <country>USA</country>
      </postal>
      <phone></phone>
      <email>mzanaty@cisco.com</email>
      </address>
    </author>

    <date year="2014" />

    <workgroup>PAYLOAD</workgroup>

    <abstract>
      <t>This document defines new RTP payload formats for the Forward Error
      Correction (FEC) packets that are generated by the non-interleaved and
      interleaved parity codes from a source media encapsulated in RTP. These
      parity codes are systematic codes, where a number of repair symbols are
      generated from a set of source symbols. These repair symbols are sent in 
      a repair flow separate from the source flow that carries the source symbols. 
      The non-interleaved and interleaved parity codes offer a good protection
      against random and bursty packet losses, respectively, at a cost of
      decent complexity. The RTP payload formats that are defined in this
      document address the scalability issues experienced with the earlier
      specifications including RFC 2733, RFC 5109 and SMPTE 2022-1, and offer
      several improvements. Due to these changes, the new payload formats are
      not backward compatible with the earlier specifications.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>This document defines new RTP payload formats for the Forward Error 
      Correction (FEC) that is generated by the non-interleaved and interleaved 
      parity codes from a source media encapsulated in RTP <xref target="RFC3550" />. 
      The type of the source media protected by these parity codes can be audio,
      video, text or application. The FEC data are generated according to the
      media type parameters, which are communicated out-of-band (e.g., in SDP).
      Furthermore, the associations or relationships between the source and repair 
      flows is also communicated out-of-band.</t>

      <t>Both the non-interleaved and interleaved parity codes use the
      exclusive OR (XOR) operation to generate the repair symbols. In a
      nutshell, the following steps take place:</t>

      <t><list style="numbers">
          <t>The sender determines a set of source packets to be protected
          by FEC based on the media type parameters.</t>

          <t>The sender applies the XOR operation on the source symbols to
          generate the required number of repair symbols.</t>

          <t>The sender packetizes the repair symbols and sends the repair
          packet(s) along with the source packets to the receiver(s) (in
          different flows). The repair packets MAY be sent proactively or
          on-demand.</t>
        </list></t>

      <!-- VS: backwards compatibility to what? -->
      <t>Note that the source and repair packets belong to different source
      and repair flows, and the sender MUST provide a way for the receivers to
      demultiplex them, even in the case they are sent in the same 5-tuple
      (i.e., same source/destination address/port with UDP). This is
      required to offer backward compatibility (See <xref
      target="sec_formats"></xref>). At the receiver side, if all of the
      source packets are successfully received, there is no need for FEC
      recovery and the repair packets are discarded. However, if there are
      missing source packets, the repair packets can be used to recover the
      missing information. <xref target="fig_encoder"></xref>
      and <xref target="fig_decoder"></xref> describe example block diagrams 
      for the systematic parity FEC encoder and decoder, respectively.</t>

      <t><figure anchor="fig_encoder"
          title="Block diagram for systematic parity FEC encoder">
          <preamble></preamble>

          <artwork align="center"><![CDATA[                           +------------+     
+--+  +--+  +--+  +--+ --> | Systematic | --> +--+  +--+  +--+  +--+
+--+  +--+  +--+  +--+     | Parity FEC |     +--+  +--+  +--+  +--+
                           |  Encoder   | 
                           |  (Sender)  | --> +==+  +==+
                           +------------+     +==+  +==+

Source Packet: +--+    Repair Packet: +==+
               +--+                   +==+]]></artwork>
        </figure></t>

      <t><figure anchor="fig_decoder"
          title="Block diagram for systematic parity FEC decoder">
          <preamble></preamble>

          <artwork align="center"><![CDATA[                           +------------+     
+--+    X    X    +--+ --> | Systematic | --> +--+  +--+  +--+  +--+  
+--+              +--+     | Parity FEC |     +--+  +--+  +--+  +--+
                           |  Decoder   |
            +==+  +==+ --> | (Receiver) |     
            +==+  +==+     +------------+
       
Source Packet: +--+    Repair Packet: +==+    Lost Packet: X 
               +--+                   +==+]]></artwork>
        </figure></t>

      <t>In <xref target="fig_decoder"></xref>, it is clear that the FEC
      packets have to be received by the endpoint within a certain amount of time
      for the FEC recovery process to be useful. In this document, we refer to the
      time that spans the source packets and the corresponding repair packets
      as the repair window. Assuming that no delay variation is present, the FEC 
      decoder SHOULD NOT wait longer than the repair window to perform recovery.
      Since additional waiting would not help the recovery process and may be too late
      to playback the packet. The size of the repair window depends on the source block 
      size and the regime adopted for sending the repair packets.</t>

      <t>Suppose that we have a group of D x L source packets that have
      sequence numbers starting from 1 running to D x L, and a repair packet
      is generated by applying the XOR operation to every L consecutive
      packets as sketched in <xref target="fig_fecblock_row"></xref>. This
      process is referred to as 1-D non-interleaved FEC protection. As a
      result of this process, D repair packets are generated, which we refer
      to as non-interleaved (or row) FEC packets.</t>

      <t><figure anchor="fig_fecblock_row"
          title="Generating non-interleaved (row) FEC packets">
          <preamble></preamble>

          <artwork align="center"><![CDATA[+--------------------------------------------------+    ---    +===+
| S_1          S_2          S3          ...  S_L   | + |XOR| = |R_1|
+--------------------------------------------------+    ---    +===+
+--------------------------------------------------+    ---    +===+
| S_L+1        S_L+2        S_L+3       ...  S_2xL | + |XOR| = |R_2|
+--------------------------------------------------+    ---    +===+
  .            .            .                .           .       .
  .            .            .                .           .       .
  .            .            .                .           .       .
+--------------------------------------------------+    ---    +===+
| S_(D-1)xL+1  S_(D-1)xL+2  S_(D-1)xL+3 ...  S_DxL | + |XOR| = |R_D|
+--------------------------------------------------+    ---    +===+]]></artwork>
        </figure></t>

      <t>If we apply the XOR operation to the group of the source packets
      whose sequence numbers are L apart from each other, as sketched in <xref
      target="fig_fecblock_column"></xref>. In this case the endpoint generates L 
      repair packets. This process is referred to as 1-D interleaved FEC 
      protection, and the resulting L repair packets are referred to as 
      interleaved (or column) FEC packets.</t>

      <t><figure anchor="fig_fecblock_column"
          title="Generating interleaved (column) FEC packets">
          <preamble></preamble>

          <artwork align="center"><![CDATA[+-------------+ +-------------+ +-------------+     +-------+
| S_1         | | S_2         | | S3          | ... | S_L   |
| S_L+1       | | S_L+2       | | S_L+3       | ... | S_2xL |
| .           | | .           | |             |     |       |
| .           | | .           | |             |     |       |
| .           | | .           | |             |     |       |
| S_(D-1)xL+1 | | S_(D-1)xL+2 | | S_(D-1)xL+3 | ... | S_DxL |
+-------------+ +-------------+ +-------------+     +-------+
       +               +               +                +
 -------------   -------------   -------------       -------
|     XOR     | |     XOR     | |     XOR     | ... |  XOR  |
 -------------   -------------   -------------       -------
       =               =               =                =
     +===+           +===+           +===+            +===+
     |C_1|           |C_2|           |C_3|      ...   |C_L|
     +===+           +===+           +===+            +===+]]></artwork>
        </figure></t>

<!-- VS: confirm it is non-interleaved OR interleaved, not both. Both 
would imply 2-D FEC! -->
      <section title="Use Cases for 1-D FEC Protection">
        <t>We generate one non-interleaved repair packet out of L consecutive
        source packets or one interleaved repair packet out of D
        non-consecutive source packets. Regardless of whether the repair
        packet is a non-interleaved or an interleaved one, it can provide a
        full recovery of the missing information if there is only one packet
        missing among the corresponding source packets. This implies that 1-D
        non-interleaved FEC protection performs better when the source packets
        are randomly lost. However, if the packet losses occur in bursts, 1-D
        interleaved FEC protection performs better provided that L is chosen
        large enough, i.e., L-packet duration SHOULD NOT be shorter than the
        observed burst duration. The sender SHOULD monitor the occurrences of
        the loss events on the source packets and instead use 2-D parity FEC 
        protection (See <xref target="sec_2d" />).</t>

        <!-- VS: removed the following because it is discussed in the
        next section:
        "generate non-interleaved and interleaved FEC packets when the
        losses occur randomly and in bursts, respectively" -->

        <t>If the sender generates non-interleaved FEC packets and a burst
        loss hits the source packets, the repair operation fails. This is
        illustrated in <xref target="fig_1d_a" />.</t>

        <t><figure anchor="fig_1d_a"
            title="Example scenario where 1-D non-interleaved FEC protection fails error recovery (Burst Loss)">
            <artwork align="center"><![CDATA[+---+                +---+  +===+
| 1 |    X      X    | 4 |  |R_1|
+---+                +---+  +===+

+---+  +---+  +---+  +---+  +===+
| 5 |  | 6 |  | 7 |  | 8 |  |R_2|
+---+  +---+  +---+  +---+  +===+  

+---+  +---+  +---+  +---+  +===+
| 9 |  | 10|  | 11|  | 12|  |R_3|
+---+  +---+  +---+  +---+  +===+
]]></artwork>
          </figure></t>

        <t>The sender may generate interleaved FEC packets to combat with the
        bursty packet losses. However, two or more random packet losses may
        hit the source and repair packets in the same column. In that case,
        the repair operation fails as well. This is illustrated in <xref
        target="fig_1d_b" />. Note that it is possible that two burst
        losses may occur back-to-back, in which case interleaved FEC packets
        may still fail to recover the lost data.</t>

        <t><figure anchor="fig_1d_b"
            title="Example scenario where 1-D interleaved FEC protection fails error recovery (Periodic Loss)">
            <artwork align="center"><![CDATA[+---+         +---+  +---+ 
| 1 |    X    | 3 |  | 4 |
+---+         +---+  +---+

+---+         +---+  +---+
| 5 |    X    | 7 |  | 8 |
+---+         +---+  +---+  

+---+  +---+  +---+  +---+
| 9 |  | 10|  | 11|  | 12|
+---+  +---+  +---+  +---+

+===+  +===+  +===+  +===+
|C_1|  |C_2|  |C_3|  |C_4|
+===+  +===+  +===+  +===+]]></artwork>
          </figure></t>
      </section>

      <section anchor="sec_2d" title="Use Cases for 2-D Parity FEC Protection">
        <t>In networks where the source packets are lost both randomly and in
        bursts, the endpoint ought to generate both non-interleaved and interleaved
        FEC packets. This type of FEC protection is known as 2-D parity FEC
        protection. At the expense of generating more FEC packets, thus
        increasing the FEC overhead, 2-D FEC provides a superior protection
        against mixed loss patterns. However, it is still possible for 
        2-D parity FEC protection to fail to recover all of the lost source
        packets if a particular loss pattern occurs. An example scenario is 
        illustrated in <xref target="fig_2d1" />.</t>

        <t><figure anchor="fig_2d1"
            title="Example scenario #1 where 2-D parity FEC protection fails error recovery">
            <artwork align="center"><![CDATA[+---+                +---+  +===+
| 1 |    X      X    | 4 |  |R_1|
+---+                +---+  +===+

+---+  +---+  +---+  +---+  +===+
| 5 |  | 6 |  | 7 |  | 8 |  |R_2|
+---+  +---+  +---+  +---+  +===+  

+---+                +---+  +===+
| 9 |    X      X    | 12|  |R_3|
+---+                +---+  +===+

+===+  +===+  +===+  +===+
|C_1|  |C_2|  |C_3|  |C_4|
+===+  +===+  +===+  +===+]]></artwork>
          </figure></t>

        <t>2-D parity FEC protection also fails when at least two rows are
        missing a source and the FEC packet and the missing source packets (in
        at least two rows) are aligned in the same column. An example loss
        pattern is sketched in <xref target="fig_2d2"></xref>. Similarly, 2-D
        parity FEC protection cannot repair all missing source packets when at
        least two columns are missing a source and the FEC packet and the
        missing source packets (in at least two columns) are aligned in the
        same row.</t>

        <t><figure anchor="fig_2d2"
            title="Example scenario #2 where 2-D parity FEC protection fails error recovery">
            <artwork align="center"><![CDATA[+---+  +---+         +---+ 
| 1 |  | 2 |    X    | 4 |    X
+---+  +---+         +---+ 

+---+  +---+  +---+  +---+  +===+
| 5 |  | 6 |  | 7 |  | 8 |  |R_2|
+---+  +---+  +---+  +---+  +===+  

+---+  +---+         +---+  
| 9 |  | 10|    X    | 12|    X
+---+  +---+         +---+  

+===+  +===+  +===+  +===+
|C_1|  |C_2|  |C_3|  |C_4|
+===+  +===+  +===+  +===+]]></artwork>
          </figure></t>
      </section>

      <section title="Overhead Computation">
        <t>The overhead is defined as the ratio of the number of bytes
        belonging to the repair packets to the number of bytes belonging to
        the protected source packets.</t>

        <t>Generally, repair packets are larger in size compared to the source
        packets. Also, not all the source packets are necessarily equal in
        size. However, if we assume that each repair packet carries an equal
        number of bytes carried by a source packet, we can compute the
        overhead for different FEC protection methods as follows:</t>

        <t><list style="symbols">
            <t>1-D Non-interleaved FEC Protection: Overhead = 1/L</t>

            <t>1-D Interleaved FEC Protection: Overhead = 1/D</t>

            <t>2-D Parity FEC Protection: Overhead = 1/L + 1/D</t>
          </list>where L and D are the number of columns and rows in the
        source block, respectively.</t>
      </section>
    </section>

    <section title="Requirements Notation">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"></xref>.</t>
    </section>

    <section title="Definitions, Notations and Abbreviations">
      <t>The definitions and notations commonly used in this document are
      summarized in this section.</t>

      <section title="Definitions">
        <t>This document uses the following definitions:</t>

        <t>Source Flow: The packet flow(s) carrying the source data and to
        which FEC protection is to be applied.</t>

        <t>Repair Flow: The packet flow(s) carrying the repair data.</t>

        <t>Symbol: A unit of data. Its size, in bytes, is referred to as the
        symbol size.</t>

        <t>Source Symbol: The smallest unit of data used during the encoding
        process.</t>

        <t>Repair Symbol: Repair symbols are generated from the source
        symbols.</t>

        <t>Source Packet: Data packets that contain only source symbols.</t>

        <t>Repair Packet: Data packets that contain only repair symbols.</t>

        <t>Source Block: A block of source symbols that are considered
        together in the encoding process.</t>
      </section>

      <section title="Notations">
        <t><list style="symbols">
            <t>L: Number of columns of the source block.</t>

            <t>D: Number of rows of the source block.</t>

            <t>ToP: Type of protection.</t>
          </list></t>
      </section>
    </section>

    <section anchor="sec_formats" title="Packet Formats">
      <t>This section defines the formats of the source and repair
      packets.</t>

      <section title="Source Packets">
        <t>The source packets MUST contain the information that identifies the
        source block and the position within the source block occupied by the
        packet. Since the source packets that are carried within an RTP stream
        already contain unique sequence numbers in their RTP headers <xref
        target="RFC3550"></xref>, we can identify the source packets in a
        straightforward manner and there is no need to append additional
        field(s). The primary advantage of not modifying the source packets in
        any way is that it provides backward compatibility for the receivers
        that do not support FEC at all. In multicast scenarios, this backward
        compatibility becomes quite useful as it allows the non-FEC-capable
        and FEC-capable receivers to receive and interpret the same source
        packets sent in the same multicast session.</t>
      </section>

      <section anchor="sec_repair_fec_payload_id" title="Repair Packets">
        <t>The repair packets MUST contain information that identifies the
        source block they pertain to and the relationship between the
        contained repair symbols and the original source block. For this
        purpose, we use the RTP header of the repair packets as well as
        another header within the RTP payload, which we refer to as the FEC
        header, as shown in <xref target="fig_repairpacket"></xref>.</t>

        <t><figure anchor="fig_repairpacket" title="Format of repair packets">
            <preamble></preamble>

            <artwork align="center"><![CDATA[+------------------------------+
|          IP Header           |
+------------------------------+
|       Transport Header       |
+------------------------------+
|          RTP Header          | __
+------------------------------+   |
|          FEC Header          |    \
+------------------------------+     > RTP Payload
|        Repair Symbols        |    /
+------------------------------+ __|]]></artwork>

            <postamble></postamble>
          </figure></t>

        <t>The RTP header is formatted according to <xref
        target="RFC3550"></xref> with some further clarifications listed
        below:</t>

        <t><list style="symbols">
            <t>Marker (M) Bit: This bit is not used for this payload type, and
            SHALL be set to 0.</t>

            <t>Payload Type: The (dynamic) payload type for the repair packets
            is determined through out-of-band means. Note that this document
            registers new payload formats for the repair packets (Refer to
            <xref target="sec_parameters"></xref> for details). According to
            <xref target="RFC3550"></xref>, an RTP receiver that cannot
            recognize a payload type must discard it. This provides backward
            compatibility. If a non-FEC-capable receiver receives a repair packet, 
            it will not recognize the payload type, and hence, will discard 
            the repair packet.</t>

            <!-- VS: removed pointer to multicast operation.
            "The FEC mechanisms can then be used in a multicast
            group with mixed FEC-capable and non-FEC-capable receivers." -->

            <t>Sequence Number (SN): The sequence number has the standard
            definition. It MUST be one higher than the sequence number in the
            previously transmitted repair packet. The initial value of the
            sequence number SHOULD be random (unpredictable, based on <xref
            target="RFC3550"></xref>).</t>

            <t>Timestamp (TS): The timestamp SHALL be set to a time
            corresponding to the repair packet's transmission time. Note that
            the timestamp value has no use in the actual FEC protection
            process and is usually useful for jitter calculations.</t>

            <t>Synchronization Source (SSRC): The SSRC value SHALL be randomly
            assigned as suggested by <xref target="RFC3550"></xref>. This
            allows the sender to multiplex the source and repair flows on the
            same port, or multiplex multiple repair flows on a single port.
            The repair flows SHOULD use the RTCP CNAME field to associate
            themselves with the source flow. 
            
            <vspace blankLines="1" />

            In some networks, the RTP Source, which produces the source packets 
            and the FEC Source, which generates the repair packets from the source
            packets may not be the same host. In such scenarios, using the
            same CNAME for the source and repair flows means that the RTP
            Source and the FEC Source MUST share the same CNAME (for this
            specific source-repair flow association). A common CNAME may be
            produced based on an algorithm that is known both to the RTP and
            FEC Source. This usage is compliant with <xref
            target="RFC3550"></xref>.
            
            <vspace blankLines="1" />

            Note that due to the randomness of the SSRC assignments, there is a 
            possibility of SSRC collision. In such cases, the collisions MUST be 
            resolved as described in <xref target="RFC3550"></xref>.</t>
          </list></t>

        <t>The FEC header is 12 octets (or 16 octets when the optional padding
        is used). The format of the FEC header is shown in <xref
        target="fig_repairfecpayloadid2"></xref>.</t>

        <t><figure anchor="fig_repairfecpayloadid2"
            title="Format of the FEC header">
            <preamble></preamble>

            <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|E|I|P|X|  CC   |M| PT recovery |            SN base            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          TS recovery                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Length recovery        |            Padding            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Padding (optional)                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure></t>

        <t>The FEC header consists of the following fields:</t>

        <t><list style="symbols">
            <t>The E bit is the extension flag reserved to indicate any future
            extension to this specification.</t>

            <t>The I bit is used to indicate the length of padding in the FEC
            header. The padding length SHOULD be selected based on the
            platform architecture and the impact of header length on the
            header processing performance.</t>

            <t>The P, X, CC, M and PT recovery fields are used to determine
            the corresponding fields of the recovered packets.</t>

            <t>The SN base field is used to indicate the lowest sequence
            number, taking wrap around into account, of those source packets
            protected by this repair packet.</t>

            <t>The TS recovery field is used to determine the timestamp of the
            recovered packets.</t>

            <t>The Length recovery field is used to determine the length of
            the recovered packets.</t>

            <t>The Padding field is used to pad the FEC header to 12 bytes
            (integer multiples of 32 bits).</t>

            <t>The second (optional) Padding field is used to pad the FEC
            header to 16 bytes (integer multiples of 64 bits).</t>
          </list></t>

        <t>The details on setting the fields in the FEC header are provided in
        <xref target="sec_repair_packet_construction"></xref>.</t>

        <t>It should be noted that a mask-based approach (similar to the ones
        specified in <xref target="RFC2733"></xref> and <xref
        target="RFC5109"></xref>) may not be very efficient to indicate which
        source packets in the current source block are associated with a given
        repair packet. In particular, for the applications that would like to
        use large source block sizes, the size of the mask that is required to
        describe the source-repair packet associations may be prohibitively
        large. Instead, a systematized approach similar to the one proposed in
        <xref target="SMPTE2022-1"></xref> is inherently more efficient. Yet,
        <xref target="SMPTE2022-1"></xref> carries the values of D and L in
        8-bit fields. While this approach can support larger blocks compared
        to the mask-based approaches, 8-bit fields may still be limiting when
        a high-bitrate source flow (e.g., a flow carrying Ultra HD video) is
        to be protected or when network outages/lossy periods span more than
        255 packets.</t>
      </section>
    </section>

    <section anchor="sec_parameters" title="Payload Format Parameters">
      <t>This section provides the media subtype registration for the
      non-interleaved and interleaved parity FEC. The parameters that are
      required to configure the FEC encoding and decoding operations are also
      defined in this section.</t>

      <section title="Media Type Registration">
        <t>This registration is done using the template defined in <xref
        target="RFC4288"></xref> and following the guidance provided in <xref
        target="RFC3555"></xref>.</t>

        <t>Note to the RFC Editor: In the following sections, please replace
        "XXXX" with the number of this document prior to publication as an
        RFC.</t>

        <section title="Registration of application/non-interleaved-parityfec">
          <t>Type name: application</t>

          <t>Subtype name: non-interleaved-parityfec</t>

          <t>Required parameters:</t>

          <t><list style="symbols">
              <t>rate: The RTP timestamp (clock) rate. The rate SHALL be
              larger than 1000 Hz to provide sufficient resolution to RTCP
              operations. However, it is RECOMMENDED to select the rate that
              matches the rate of the protected source RTP stream.</t>

              <t>L: Number of columns of the source block. L is a positive
              integer.</t>

              <t>D: Number of rows of the source block. D is a positive
              integer.</t>

              <t>ToP: Type of the protection applied by the sender: 0 for 1-D
              interleaved FEC protection, 1 for 1-D non-interleaved FEC
              protection, and 2 for 2-D parity FEC protection. The ToP value
              of 3 is reserved for future uses.</t>

              <t>repair-window: The time that spans the source packets and the
              corresponding repair packets. The size of the repair window is
              specified in microseconds.</t>
            </list>Optional parameters: None.</t>

          <t>Encoding considerations: This media type is framed (See Section
          4.8 in the template document <xref target="RFC4288"></xref>) and
          contains binary data.</t>

          <t>Security considerations: See <xref
          target="sec_security_considerations"></xref> of [RFCXXXX].</t>

          <t>Interoperability considerations: None.</t>

          <t>Published specification: [RFCXXXX].</t>

          <t>Applications that use this media type: Multimedia applications
          that want to improve resiliency against packet loss by sending
          redundant data in addition to the source media.</t>

          <t>Additional information: None.</t>

          <t>Person &amp; email address to contact for further information:
          Ali Begen &lt;abegen@cisco.com&gt; and IETF Audio/Video Transport
          Working Group.</t>

          <t>Intended usage: COMMON.</t>

          <t>Restriction on usage: This media type depends on RTP framing, and
          hence, is only defined for transport via RTP <xref
          target="RFC3550"></xref>.</t>

          <t>Author: Ali Begen &lt;abegen@cisco.com&gt;.</t>

          <t>Change controller: IETF Audio/Video Transport Working Group
          delegated from the IESG.</t>
        </section>

        <section title="Registration of application/interleaved-parityfec">
          <t>Type name: application</t>

          <t>Subtype name: interleaved-parityfec</t>

          <t>Required parameters:</t>

          <t><list style="symbols">
              <t>rate: The RTP timestamp (clock) rate. The rate SHALL be
              larger than 1000 Hz to provide sufficient resolution to RTCP
              operations. However, it is RECOMMENDED to select the rate that
              matches the rate of the protected source RTP stream.</t>

              <t>L: Number of columns of the source block. L is a positive
              integer.</t>

              <t>D: Number of rows of the source block. D is a positive
              integer.</t>

              <t>ToP: Type of the protection applied by the sender: 0 for 1-D
              interleaved FEC protection, 1 for 1-D non-interleaved FEC
              protection, and 2 for 2-D parity FEC protection. The ToP value
              of 3 is reserved for future uses.</t>

              <t>repair-window: The time that spans the source packets and the
              corresponding repair packets. The size of the repair window is
              specified in microseconds.</t>
            </list>Optional parameters: None.</t>

          <t>Encoding considerations: This media type is framed (See Section
          4.8 in the template document <xref target="RFC4288"></xref>) and
          contains binary data.</t>

          <t>Security considerations: See <xref
          target="sec_security_considerations"></xref> of [RFCXXXX].</t>

          <t>Interoperability considerations: None.</t>

          <t>Published specification: [RFCXXXX].</t>

          <t>Applications that use this media type: Multimedia applications
          that want to improve resiliency against packet loss by sending
          redundant data in addition to the source media.</t>

          <t>Additional information: None.</t>

          <t>Person &amp; email address to contact for further information:
          Ali Begen &lt;abegen@cisco.com&gt; and IETF Audio/Video Transport
          Working Group.</t>

          <t>Intended usage: COMMON.</t>

          <t>Restriction on usage: This media type depends on RTP framing, and
          hence, is only defined for transport via RTP <xref
          target="RFC3550"></xref>.</t>

          <t>Author: Ali Begen &lt;abegen@cisco.com&gt;.</t>

          <t>Change controller: IETF Audio/Video Transport Working Group
          delegated from the IESG.</t>
        </section>
      </section>

      <section title="Mapping to SDP Parameters">
        <t>Applications that are using RTP transport commonly use Session
        Description Protocol (SDP) <xref target="RFC4566"></xref> to describe
        their RTP sessions. The information that is used to specify the media
        types in an RTP session has specific mappings to the fields in an SDP
        description. In this section, we provide these mappings for the media
        subtypes registered by this document. Note that if an application does
        not use SDP to describe the RTP sessions, an appropriate mapping must
        be defined and used to specify the media types and their parameters
        for the control/description protocol employed by the application.</t>

        <t>The mapping of the media type specification for
        "non-interleaved-parityfec" and "interleaved-parityfec" and their
        parameters in SDP is as follows:</t>

        <t><list style="symbols">
            <t>The media type (e.g., "application") goes into the "m=" line as
            the media name.</t>

            <t>The media subtype goes into the "a=rtpmap" line as the encoding
            name. The RTP clock rate parameter ("rate") also goes into the
            "a=rtpmap" line as the clock rate.</t>

            <t>The remaining required payload-format-specific parameters go
            into the "a=fmtp" line by copying them directly from the media
            type string as a semicolon-separated list of parameter=value
            pairs.</t>
          </list>SDP examples are provided in <xref
        target="sec_sdp"></xref>.</t>

        <section title="Offer-Answer Model Considerations">
          <t>When offering 1-D interleaved parity FEC over RTP using SDP in an
          Offer/Answer model <xref target="RFC3264"></xref>, the following
          considerations apply:</t>

          <t><list style="symbols">
              <t>Each combination of the L and D parameters produces a
              different FEC data and is not compatible with any other
              combination. A sender application may desire to offer multiple
              offers with different sets of L and D values as long as the
              parameter values are valid. The receiver SHOULD normally choose
              the offer that has a sufficient amount of interleaving. If
              multiple such offers exist, the receiver may choose the offer
              that has the lowest overhead or the one that requires the
              smallest amount of buffering. The selection depends on the
              application requirements.</t>

              <t>The value for the repair-window parameter depends on the L
              and D values and cannot be chosen arbitrarily. More
              specifically, L and D values determine the lower limit for the
              repair-window size. The upper limit of the repair-window size
              does not depend on the L and D values.</t>

              <t>Although combinations with the same L and D values but with
              different repair-window sizes produce the same FEC data, such
              combinations are still considered different offers. The size of
              the repair-window is related to the maximum delay between the
              transmission of a source packet and the associated repair
              packet. This directly impacts the buffering requirement on the
              receiver side and the receiver must consider this when choosing
              an offer.</t>

              <t>There are no optional format parameters defined for this
              payload. Any unknown option in the offer MUST be ignored and
              deleted from the answer. If FEC is not desired by the receiver,
              it can be deleted from the answer.</t>
            </list></t>
        </section>

        <section title="Declarative Considerations">
          <t>In declarative usage, like SDP in the Real-time Streaming
          Protocol (RTSP) <xref target="RFC2326"></xref> or the Session
          Announcement Protocol (SAP) <xref target="RFC2974"></xref>, the
          following considerations apply:</t>

          <t><list style="symbols">
              <t>The payload format configuration parameters are all
              declarative and a participant MUST use the configuration that is
              provided for the session.</t>

              <t>More than one configuration may be provided (if desired) by
              declaring multiple RTP payload types. In that case, the
              receivers should choose the repair flow that is best for
              them.</t>
            </list></t>
        </section>
      </section>
    </section>

    <section title="Protection and Recovery Procedures">
      <t>This section provides a complete specification of the 1-D and 2-D
      parity codes and their RTP payload formats.</t>

      <section title="Overview">
        <t>The following sections specify the steps involved in generating the
        repair packets and reconstructing the missing source packets from the
        repair packets.</t>
      </section>

      <section anchor="sec_repair_packet_construction"
               title="Repair Packet Construction">
        <t>The RTP header of a repair packet is formed based on the guidelines
        given in <xref target="sec_repair_fec_payload_id"></xref>.</t>

        <t>The FEC header includes 12 octets (or 16 octets when the optional
        padding is used). It is constructed by applying the XOR operation on
        the bit strings that are generated from the individual source packets
        protected by this particular repair packet. The set of the source
        packets that are associated with a given repair packet can be computed
        by the formula given in <xref
        target="sec_associating_source_repair"></xref>.</t>

        <t>The bit string is formed for each source packet by concatenating
        the following fields together in the order specified:</t>

        <t><list style="symbols">
            <t>The first 64 bits of the RTP header (64 bits).</t>

            <t>Unsigned network-ordered 16-bit representation of the source
            packet length in bytes minus 12 (for the fixed RTP header), i.e.,
            the sum of the lengths of all the following if present: the CSRC
            list, extension header, RTP payload and RTP padding (16 bits).</t>
          </list>By applying the parity operation on the bit strings produced
        from the source packets, we generate the FEC bit string. The FEC
        header is generated from the FEC bit string as follows:</t>

        <t><list style="symbols">
            <t>The first (most significant) 2 bits in the FEC bit string are
            skipped. The E bit in the FEC header is set to 0. The I bit in the
            FEC header is set to 0 if only 2-byte padding is used, or to 1 if
            6-byte padding is used.</t>

            <t>The next bit in the FEC bit string is written into the P
            recovery bit in the FEC header.</t>

            <t>The next bit in the FEC bit string is written into the X
            recovery bit in the FEC header.</t>

            <t>The next 4 bits of the FEC bit string are written into the CC
            recovery field in the FEC header.</t>

            <t>The next bit is written into the M recovery bit in the FEC
            header.</t>

            <t>The next 7 bits of the FEC bit string are written into the PT
            recovery field in the FEC header.</t>

            <t>The next 16 bits are skipped.</t>

            <t>The next 32 bits of the FEC bit string are written into the TS
            recovery field in the FEC header.</t>

            <t>The next 16 bits are written into the length recovery field in
            the FEC header.</t>

            <t>The 2-byte padding field of the FEC header SHALL be set to
            0.</t>

            <t>If the I bit is set to 1, indicating that 6-byte padding is
            used, four more bytes SHALL be added to the FEC header and these
            bytes SHALL be set to 0.</t>
          </list>As described in <xref
        target="sec_repair_fec_payload_id"></xref>, the SN base field of the
        FEC header MUST be set to the lowest sequence number of the source
        packets protected by this repair packet. For the interleaved FEC
        packets, this corresponds to the lowest sequence number of the source
        packets that form the column. For the non-interleaved FEC packets, the
        SN base field MUST be set to the lowest sequence number of the source
        packets that form the row.</t>

        <t>The repair packet payload consists of the bits that are generated
        by applying the XOR operation on the payloads of the source RTP
        packets. If the payload lengths of the source packets are not equal,
        each shorter packet MUST be padded to the length of the longest packet
        by adding octet 0's at the end.</t>

        <t>Due to this possible padding and mandatory FEC header, a repair
        packet has a larger size than the source packets it protects. This may
        cause problems if the resulting repair packet size exceeds the Maximum
        Transmission Unit (MTU) size of the path over which the repair flow is
        sent.</t>
      </section>

      <section title="Source Packet Reconstruction">
        <t>This section describes the recovery procedures that are required to
        reconstruct the missing source packets. The recovery process has two
        steps. In the first step, the FEC decoder determines which source and
        repair packets should be used in order to recover a missing packet. In
        the second step, the decoder recovers the missing packet, which
        consists of an RTP header and RTP payload.</t>

        <t>In the following, we describe the RECOMMENDED algorithms for the
        first and second steps. Based on the implementation, different
        algorithms MAY be adopted. However, the end result MUST be identical
        to the one produced by the algorithms described below.</t>

        <t>Note that the same algorithms are used by the 1-D parity codes,
        regardless of whether the FEC protection is applied over a column or a
        row. The 2-D parity codes, on the other hand, usually require multiple
        iterations of the procedures described here. This iterative decoding
        algorithm is further explained in <xref
        target="sec_iterative_decoding"></xref>.</t>

        <section anchor="sec_associating_source_repair"
                 title="Associating the Source and Repair Packets">
          <t>The first step is associating the source and repair packets. By
          virtue of the payload type field in the RTP header, each repair
          packet is indicated whether it is an interleaved or non-interleaved
          FEC packet. In addition, the SN base field in the FEC header shows
          the lowest sequence number of the source packets that form the
          particular column or row. Finally, the information of how many
          source packets are included in each column or row is available from
          the media type parameters specified in the SDP description. This set
          of information uniquely identifies all of the source packets
          associated with a given repair packet.</t>

          <t>Mathematically, for any received repair packet, p*, we can
          determine the sequence numbers of the source packets that are
          protected by this repair packet as follows:</t>

          <t><figure>
              <preamble></preamble>

              <artwork align="center"><![CDATA[p*_snb + i * X_1 (modulo 65536)]]></artwork>
            </figure></t>

          <t>where p*_snb denotes the value in the SN base field of p*'s FEC
          header, X_1 is set to L and 1 for the interleaved and
          non-interleaved FEC packets, respectively, and</t>

          <t><figure>
              <preamble></preamble>

              <artwork align="center"><![CDATA[0 <= i < X_2]]></artwork>
            </figure></t>

          <t>where X_2 is set to D and L for the interleaved and
          non-interleaved FEC packets, respectively.</t>

          <t>We denote the set of the source packets associated with repair
          packet p* by set T(p*). Note that in a source block whose size is L
          columns by D rows, set T includes D source packets plus one repair
          packet for the FEC protection applied over a column, and L source
          packets plus one repair packet for the FEC protection applied over a
          row. Recall that 1-D interleaved and non-interleaved FEC protection
          can fully recover the missing information if there is only one
          source packet missing in set T. If there are more than one source
          packets missing in set T, 1-D FEC protection will not work.</t>
        </section>

        <section anchor="sec_recovering_rtp_header"
                 title="Recovering the RTP Header">
          <t>For a given set T, the procedure for the recovery of the RTP
          header of the missing packet, whose sequence number is denoted by
          SEQNUM, is as follows:</t>

          <t><list style="numbers">
              <t>For each of the source packets that are successfully received
              in T, compute the 80-bit string by concatenating the first 64
              bits of their RTP header and the unsigned network-ordered 16-bit
              representation of their length in bytes minus 12.</t>

              <t>For the repair packet in T, compute the FEC bit string from
              the first 80 bits of the FEC header.</t>

              <t>Calculate the recovered bit string as the XOR of the bit
              strings generated from all source packets in T and the FEC bit
              string generated from the repair packet in T.</t>

              <t>Create a new packet with the standard 12-byte RTP header and
              no payload.</t>

              <t>Set the version of the new packet to 2. Skip the first 2 bits
              in the recovered bit string.</t>

              <t>Set the Padding bit in the new packet to the next bit in the
              recovered bit string.</t>

              <t>Set the Extension bit in the new packet to the next bit in
              the recovered bit string.</t>

              <t>Set the CC field to the next 4 bits in the recovered bit
              string.</t>

              <t>Set the Marker bit in the new packet to the next bit in the
              recovered bit string.</t>

              <t>Set the Payload type in the new packet to the next 7 bits in
              the recovered bit string.</t>

              <t>Set the SN field in the new packet to SEQNUM. Skip the next
              16 bits in the recovered bit string.</t>

              <t>Set the TS field in the new packet to the next 32 bits in the
              recovered bit string.</t>

              <t>Take the next 16 bits of the recovered bit string and set the
              new variable Y to whatever unsigned integer this represents
              (assuming network order). Convert Y to host order. Y represents
              the length of the new packet in bytes minus 12 (for the fixed
              RTP header), i.e., the sum of the lengths of all the following
              if present: the CSRC list, header extension, RTP payload and RTP
              padding.</t>

              <t>Set the SSRC of the new packet to the SSRC of the source RTP
              stream.</t>
            </list>This procedure recovers the header of an RTP packet up to
          (and including) the SSRC field.</t>
        </section>

        <section anchor="sec_recovering_rtp_payload"
                 title="Recovering the RTP Payload">
          <t>Following the recovery of the RTP header, the procedure for the
          recovery of the RTP payload is as follows:</t>

          <t><list style="numbers">
              <t>Append Y bytes to the new packet.</t>

              <t>For each of the source packets that are successfully received
              in T, compute the bit string from the Y octets of data starting
              with the 13th octet of the packet. If any of the bit strings
              generated from the source packets has a length shorter than Y,
              pad them to that length. The padding of octet 0 MUST be added at
              the end of the bit string. Note that the information of the
              first 8 octets are protected by the FEC header.</t>

              <t>For the repair packet in T, compute the FEC bit string from
              the repair packet payload, i.e., the Y octets of data following
              the FEC header. Note that the FEC header may be 12 octets or 16
              octets depending on whether the optional padding is used or
              not.</t>

              <t>Calculate the recovered bit string as the XOR of the bit
              strings generated from all source packets in T and the FEC bit
              string generated from the repair packet in T.</t>

              <t>Append the recovered bit string (Y octets) to the new packet
              generated in <xref
              target="sec_recovering_rtp_header"></xref>.</t>
            </list></t>
        </section>

        <section anchor="sec_iterative_decoding"
                 title="Iterative Decoding Algorithm for the 2-D Parity FEC Protection">
          <t>In 2-D parity FEC protection, the sender generates both
          non-interleaved and interleaved FEC packets to combat with the mixed
          loss patterns (random and bursty). At the receiver side, these FEC
          packets are used iteratively to overcome the shortcomings of the 1-D
          non-interleaved/interleaved FEC protection and improve the chances
          of full error recovery.</t>

          <t>The iterative decoding algorithm runs as follows:</t>

          <t><list style="numbers">
              <t>Set num_recovered_until_this_iteration to zero</t>

              <t>Set num_recovered_so_far to zero</t>

              <t>Recover as many source packets as possible by using the
              non-interleaved FEC packets as outlined in <xref
              target="sec_recovering_rtp_header"></xref> and <xref
              target="sec_recovering_rtp_payload"></xref>, and increase the
              value of num_recovered_so_far by the number of recovered source
              packets.</t>

              <t>Recover as many source packets as possible by using the
              interleaved FEC packets as outlined in <xref
              target="sec_recovering_rtp_header"></xref> and <xref
              target="sec_recovering_rtp_payload"></xref>, and increase the
              value of num_recovered_so_far by the number of recovered source
              packets.</t>

              <t>If num_recovered_so_far &gt;
              num_recovered_until_this_iteration<vspace
              blankLines="0" />---num_recovered_until_this_iteration =
              num_recovered_so_far<vspace blankLines="0" />---Go to step
              3<vspace blankLines="0" />Else<vspace
              blankLines="0" />---Terminate</t>
            </list></t>

          <t>The algorithm terminates either when all missing source packets
          are fully recovered or when there are still remaining missing source
          packets but the FEC packets are not able to recover any more source
          packets. For the example scenarios when the 2-D parity FEC
          protection fails full recovery, refer to <xref
          target="sec_2d"></xref>. Upon termination, variable
          num_recovered_so_far has a value equal to the total number of
          recovered source packets.</t>

          <t>Example:</t>

          <t>Suppose that the receiver experienced the loss pattern sketched
          in <xref target="fig_ite1"></xref>.</t>

          <t><figure anchor="fig_ite1"
              title="Example loss pattern for the iterative decoding algorithm">
              <artwork align="center"><![CDATA[              +---+  +---+  +===+
  X      X    | 3 |  | 4 |  |R_1|
              +---+  +---+  +===+

+---+  +---+  +---+  +---+  +===+
| 5 |  | 6 |  | 7 |  | 8 |  |R_2|
+---+  +---+  +---+  +---+  +===+  

+---+                +---+  +===+
| 9 |    X      X    | 12|  |R_3|
+---+                +---+  +===+

+===+  +===+  +===+  +===+
|C_1|  |C_2|  |C_3|  |C_4|
+===+  +===+  +===+  +===+]]></artwork>
            </figure></t>

          <t>The receiver executes the iterative decoding algorithm and
          recovers source packets #1 and #11 in the first iteration. The
          resulting pattern is sketched in <xref
          target="fig_ite2"></xref>.</t>

          <t><figure anchor="fig_ite2"
              title="The resulting pattern after the first iteration">
              <artwork align="center"><![CDATA[+---+         +---+  +---+  +===+
| 1 |    X    | 3 |  | 4 |  |R_1|
+---+         +---+  +---+  +===+

+---+  +---+  +---+  +---+  +===+
| 5 |  | 6 |  | 7 |  | 8 |  |R_2|
+---+  +---+  +---+  +---+  +===+  

+---+         +---+  +---+  +===+
| 9 |    X    | 11|  | 12|  |R_3|
+---+         +---+  +---+  +===+

+===+  +===+  +===+  +===+
|C_1|  |C_2|  |C_3|  |C_4|
+===+  +===+  +===+  +===+]]></artwork>
            </figure></t>

          <t>Since the if condition holds true, the receiver runs a new
          iteration. In the second iteration, source packets #2 and #10 are
          recovered, resulting in a full recovery as sketched in <xref
          target="fig_ite3"></xref>.</t>

          <t><figure anchor="fig_ite3"
              title="The resulting pattern after the second iteration">
              <artwork align="center"><![CDATA[+---+  +---+  +---+  +---+  +===+
| 1 |  | 2 |  | 3 |  | 4 |  |R_1|
+---+  +---+  +---+  +---+  +===+

+---+  +---+  +---+  +---+  +===+
| 5 |  | 6 |  | 7 |  | 8 |  |R_2|
+---+  +---+  +---+  +---+  +===+  

+---+  +---+  +---+  +---+  +===+
| 9 |  | 10|  | 11|  | 12|  |R_3|
+---+  +---+  +---+  +---+  +===+ 

+===+  +===+  +===+  +===+
|C_1|  |C_2|  |C_3|  |C_4|
+===+  +===+  +===+  +===+]]></artwork>
            </figure></t>
        </section>
      </section>
    </section>

    <section anchor="sec_sdp" title="SDP Examples">
      <t>This section provides two SDP <xref target="RFC4566"></xref>
      examples. The examples use the FEC grouping semantics defined in <xref
      target="RFC4756"></xref>.</t>

      <section title="Example SDP for 1-D Parity FEC Protection">
        <t>In this example, we have one source video stream (mid:S1) and one
        FEC repair stream (mid:R1). We form one FEC group with the
        "a=group:FEC S1 R1" line. The source and repair streams are sent to
        the same port on different multicast groups. The repair window is set
        to 200 ms.</t>

        <t><figure>
            <preamble></preamble>

            <artwork><![CDATA[     v=0
     o=ali 1122334455 1122334466 IN IP4 fec.example.com
     s=1-D Interleaved Parity FEC Example
     t=0 0
     a=group:FEC S1 R1
     m=video 30000 RTP/AVP 100
     c=IN IP4 233.252.0.1/127
     a=rtpmap:100 MP2T/90000
     a=mid:S1
     m=application 30000 RTP/AVP 110
     c=IN IP4 233.252.0.2/127
     a=rtpmap:110 interleaved-parityfec/90000
     a=fmtp:110 L:5; D:10; ToP:0; repair-window:200000
     a=mid:R1
]]></artwork>
          </figure></t>
      </section>

      <section title="Example SDP for 2-D Parity FEC Protection">
        <t>In this example, we have one source video stream (mid:S1) and two
        FEC repair streams (mid:R1 and mid:R2). We form one FEC group with the
        "a=group:FEC S1 R1 R2" line. The source and repair streams are sent to
        the same port on different multicast groups. The repair window is set
        to 200 ms.</t>

        <t><figure>
            <preamble></preamble>

            <artwork><![CDATA[     v=0
     o=ali 1122334455 1122334466 IN IP4 fec.example.com
     s=2-D Parity FEC Example
     t=0 0
     a=group:FEC S1 R1 R2
     m=video 30000 RTP/AVP 100
     c=IN IP4 233.252.0.1/127
     a=rtpmap:100 MP2T/90000
     a=mid:S1
     m=application 30000 RTP/AVP 110
     c=IN IP4 233.252.0.2/127
     a=rtpmap:110 interleaved-parityfec/90000
     a=fmtp:110 L:5; D:10; ToP:2; repair-window:200000
     a=mid:R1
     m=application 30000 RTP/AVP 111
     c=IN IP4 233.252.0.3/127
     a=rtpmap:111 non-interleaved-parityfec/90000
     a=fmtp:111 L:5; D:10; ToP:2; repair-window:200000
     a=mid:R2
]]></artwork>

            <postamble></postamble>
          </figure></t>

        <t>Note that the sender might be generating two repair flows carrying
        non-interleaved and interleaved FEC packets, however the receiver
        might be interested only in the interleaved FEC packets. The receiver
        can identify the repair flow carrying the desired repair data by
        checking the payload types associated with each repair flow described
        in the SDP description.</t>
      </section>
    </section>

    <section title="Congestion Control Considerations">
      <t>FEC is an effective approach to provide applications resiliency
      against packet losses. However, in networks where the congestion is a
      major contributor to the packet loss, the potential impacts of using FEC
      SHOULD be considered carefully before injecting the repair flows into
      the network. In particular, in bandwidth-limited networks, FEC repair
      flows may consume most or all of the available bandwidth and
      consequently may congest the network. In such cases, the applications
      MUST NOT arbitrarily increase the amount of FEC protection since doing
      so may lead to a congestion collapse. If desired, stronger FEC
      protection MAY be applied only after the source rate has been
      reduced.</t>

      <t>In a network-friendly implementation, an application SHOULD NOT
      send/receive FEC repair flows if it knows that sending/receiving those
      FEC repair flows would not help at all in recovering the missing
      packets. Such a practice helps reduce the amount of wasted bandwidth. It
      is RECOMMENDED that the amount of FEC protection is adjusted dynamically
      based on the packet loss rate observed by the applications.</t>

      <t>In multicast scenarios, it may be difficult to optimize the FEC
      protection per receiver. If there is a large variation among the levels
      of FEC protection needed by different receivers, it is RECOMMENDED that
      the sender offers multiple repair flows with different levels of FEC
      protection and the receivers join the corresponding multicast sessions
      to receive the repair flow(s) that is best for them.</t>

      <t>Editor's note: Additional congestion control considerations regarding
      the use of 2-D parity codes should be added here.</t>
    </section>

    <section anchor="sec_security_considerations"
             title="Security Considerations">
      <t>RTP packets using the payload format defined in this specification
      are subject to the security considerations discussed in the RTP
      specification <xref target="RFC3550"></xref> and in any applicable RTP
      profile. The main security considerations for the RTP packet carrying
      the RTP payload format defined within this memo are confidentiality,
      integrity and source authenticity. Confidentiality is achieved by
      encrypting the RTP payload. Integrity of the RTP packets is achieved
      through a suitable cryptographic integrity protection mechanism. Such a
      cryptographic system may also allow the authentication of the source of
      the payload. A suitable security mechanism for this RTP payload format
      should provide confidentiality, integrity protection, and at least
      source authentication capable of determining if an RTP packet is from a
      member of the RTP session.</t>

      <t>Note that the appropriate mechanism to provide security to RTP and
      payloads following this memo may vary. It is dependent on the
      application, transport and signaling protocol employed. Therefore, a
      single mechanism is not sufficient, although if suitable, using the
      Secure Real-time Transport Protocol (SRTP) <xref
      target="RFC3711"></xref> is recommended. Other mechanisms that may be
      used are IPsec <xref target="RFC4301"></xref> and Transport Layer
      Security (TLS) <xref target="RFC5246"></xref> (RTP over TCP); other
      alternatives may exist.</t>
    </section>

    <section anchor="sec_iana_considerations" title="IANA Considerations">
      <t>New media subtypes are subject to IANA registration. For the
      registration of the payload formats and their parameters introduced in
      this document, refer to <xref target="sec_parameters"></xref>.</t>
    </section>

    <section title="Acknowledgments">
      <t>Some parts of this document are borrowed from <xref
      target="RFC5109"></xref>. Thus, the author would like to thank the
      editor of <xref target="RFC5109"></xref> and those who contributed to
      <xref target="RFC5109"></xref>.</t>

      <t>The author would also like to thank the FEC Framework Design Team for
      their inputs, suggestions and contributions.</t>
    </section>

    <section title="Change Log">
      <t></t>

      <section title="draft-singh-payload-1d2d-parity-scheme-00">
        <t>This is the initial version, which is based on 
        draft-ietf-fecframe-1d2d-parity-scheme-00. 
        The following are the major changes compared to that document:</t>
        <t><list style="symbols">
          <t>Removed superfluous Media Type registrations, kept only application/.</t>
        </list></t>

      </section>

      <section title="draft-ietf-fecframe-1d2d-parity-scheme-00">
        <t><list style="symbols">
            <t>Some details were added regarding the use of CNAME field.</t>

            <t>Offer-Answer and Declarative Considerations sections have been
            completed.</t>

            <t>Security Considerations section has been completed.</t>
            
            <t>The timestamp field definition has changed.</t>

          </list></t>
      </section>

    </section>
  </middle>

  <back>
    <references title="Normative References">
      &__reference.RFC.2119;

      &__reference.RFC.3550;

      &__reference.RFC.4566;

      &__reference.RFC.4288;

      &__reference.RFC.3555;

      &__reference.RFC.4756;

      &__reference.RFC.3264;
    </references>

    <references title="Informative References">
      &__reference.RFC.2733;

      &__reference.RFC.5109;

      <reference anchor="SMPTE2022-1">
        <front>
          <title>Forward Error Correction for Real-Time Video/Audio Transport
          over IP Networks</title>

          <author fullname="" surname="SMPTE 2022-1-2007">
            <organization></organization>
          </author>

          <date year="2007" />
        </front>
      </reference>

      &__reference.RFC.2326;

      &__reference.RFC.2974;

      &__reference.RFC.3711;

      &__reference.RFC.4301;

      &__reference.RFC.5246;
    </references>
  </back>
</rfc>
